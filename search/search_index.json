{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udf09 Overview \u00b6 Summary \u00b6 ChainBridge is an extensible cross-chain communication protocol. It currently supports bridging between EVM and Substrate based chains. A bridge contract (or pallet in Substrate) on each chain forms either side of a bridge. Handler contracts allow for customizable behavior upon receiving transactions to and from the bridge. For example locking up an asset on one side and minting a new one on the other. Its highly customizable - you can deploy a handler contract to perform any action you like. In its current state ChainBridge operates under a trusted federation model. Deposit events on one chain are detected by a trusted set of off-chain relayers who await finality, submit events to the other chain and vote on submissions to reach acceptance triggering the appropriate handler. Research is currently underway to reduce the levels of trust required and move toward a fully trust-less bridge. Relevant repos \u00b6 ChainBridge \u00b6 This is the core bridging software that Relayers run between chains. chainbridge-solidity \u00b6 The Solidity contracts required for chainbridge. Includes deployment and interaction CLI. chainbridge-substrate \u00b6 A substrate pallet that can be integrated into a chain, as well as an example pallet to demonstrate chain integration. chainbridge-utils \u00b6 A collection of packages used by the core bridging software. chainbridge-deploy \u00b6 Some tooling to help with deployments.","title":"Overview"},{"location":"#overview","text":"","title":"\ud83c\udf09  Overview "},{"location":"#summary","text":"ChainBridge is an extensible cross-chain communication protocol. It currently supports bridging between EVM and Substrate based chains. A bridge contract (or pallet in Substrate) on each chain forms either side of a bridge. Handler contracts allow for customizable behavior upon receiving transactions to and from the bridge. For example locking up an asset on one side and minting a new one on the other. Its highly customizable - you can deploy a handler contract to perform any action you like. In its current state ChainBridge operates under a trusted federation model. Deposit events on one chain are detected by a trusted set of off-chain relayers who await finality, submit events to the other chain and vote on submissions to reach acceptance triggering the appropriate handler. Research is currently underway to reduce the levels of trust required and move toward a fully trust-less bridge.","title":"Summary"},{"location":"#relevant-repos","text":"","title":"Relevant repos"},{"location":"#chainbridge","text":"This is the core bridging software that Relayers run between chains.","title":"ChainBridge"},{"location":"#chainbridge-solidity","text":"The Solidity contracts required for chainbridge. Includes deployment and interaction CLI.","title":"chainbridge-solidity"},{"location":"#chainbridge-substrate","text":"A substrate pallet that can be integrated into a chain, as well as an example pallet to demonstrate chain integration.","title":"chainbridge-substrate"},{"location":"#chainbridge-utils","text":"A collection of packages used by the core bridging software.","title":"chainbridge-utils"},{"location":"#chainbridge-deploy","text":"Some tooling to help with deployments.","title":"chainbridge-deploy"},{"location":"cli-options/","text":"CLI Options \u00b6 Flags \u00b6 Global \u00b6 -- config value JSON configuration file -- verbosity value Supports levels crit ( silent ) to trce ( trace ) ( default : \"info\" ) -- keystore value Path to keystore directory ( default : \"./keys\" ) -- blockstore value Specify path for blockstore -- fresh Disables loading from blockstore at start . Opts will still be used if specified . ( default : false ) -- latest Overrides blockstore and start block , starts from latest block ( default : false ) -- metrics Enables metric server ( default : false ) -- metricsPort value Port to serve metrics on ( default : 8001 ) -- testkey value Applies a predetermined test keystore to the chains . -- help , - h show help ( default : false ) -- version , - v print the version ( default : false ) Account Management \u00b6 The commands can be used to manage keys in the local keystore. You can view available keys with chainbridge accounts list . chainbridge accounts generate \u00b6 -- password value Password used to encrypt the keystore . Used with -- generate , -- import , or -- unlock -- sr25519 Specify account / key type as sr25519 . ( default : false ) -- secp256k1 Specify account / key type as secp256k1 . ( default : false ) -- network value Specify the network to use for the address encoding ( substrate / polkadot / centrifuge ) ( default : substrate ) chainbridge accounts import \u00b6 -- ethereum Import an existing ethereum keystore , such as from geth . ( default : false ) -- privateKey value Import a hex representation of a private key into a keystore . -- sr25519 Specify account / key type as sr25519 . ( default : false ) -- secp256k1 Specify account / key type as secp256k1 . ( default : false ) -- password value Password used to encrypt the keystore . Used with -- generate , -- import , or -- unlock -- network value Specify the network to use for the address encoding ( substrate / polkadot / centrifuge ) ( default : substrate ) Environment Variables \u00b6 KEYSTORE_PASSWORD : The password to use when loading the keystore. BLOCK_TIMEOUT : The duration (seconds) until a chain is considered \"unhealthy\"","title":"CLI Options"},{"location":"cli-options/#cli-options","text":"","title":"CLI Options"},{"location":"cli-options/#flags","text":"","title":"Flags"},{"location":"cli-options/#global","text":"-- config value JSON configuration file -- verbosity value Supports levels crit ( silent ) to trce ( trace ) ( default : \"info\" ) -- keystore value Path to keystore directory ( default : \"./keys\" ) -- blockstore value Specify path for blockstore -- fresh Disables loading from blockstore at start . Opts will still be used if specified . ( default : false ) -- latest Overrides blockstore and start block , starts from latest block ( default : false ) -- metrics Enables metric server ( default : false ) -- metricsPort value Port to serve metrics on ( default : 8001 ) -- testkey value Applies a predetermined test keystore to the chains . -- help , - h show help ( default : false ) -- version , - v print the version ( default : false )","title":"Global"},{"location":"cli-options/#account-management","text":"The commands can be used to manage keys in the local keystore. You can view available keys with chainbridge accounts list .","title":"Account Management"},{"location":"cli-options/#chainbridge-accounts-generate","text":"-- password value Password used to encrypt the keystore . Used with -- generate , -- import , or -- unlock -- sr25519 Specify account / key type as sr25519 . ( default : false ) -- secp256k1 Specify account / key type as secp256k1 . ( default : false ) -- network value Specify the network to use for the address encoding ( substrate / polkadot / centrifuge ) ( default : substrate )","title":"chainbridge accounts generate"},{"location":"cli-options/#chainbridge-accounts-import","text":"-- ethereum Import an existing ethereum keystore , such as from geth . ( default : false ) -- privateKey value Import a hex representation of a private key into a keystore . -- sr25519 Specify account / key type as sr25519 . ( default : false ) -- secp256k1 Specify account / key type as secp256k1 . ( default : false ) -- password value Password used to encrypt the keystore . Used with -- generate , -- import , or -- unlock -- network value Specify the network to use for the address encoding ( substrate / polkadot / centrifuge ) ( default : substrate )","title":"chainbridge accounts import"},{"location":"cli-options/#environment-variables","text":"KEYSTORE_PASSWORD : The password to use when loading the keystore. BLOCK_TIMEOUT : The duration (seconds) until a chain is considered \"unhealthy\"","title":"Environment Variables"},{"location":"configuration/","text":"Configuration \u00b6 Note: TOML configs have been deprecated in favour of JSON A chain configurations take this form: { \"name\": \"eth\", // Human-readable name \"type\": \"ethereum\", // Chain type (eg. \"ethereum\" or \"substrate\") \"id\": \"0\", // Chain ID \"endpoint\": \"ws://<host>:<port>\", // Node endpoint \"from\": \"0xff93...\", // On-chain address of relayer \"opts\": {}, // Chain-specific configuration options (see below) } See config.json.example for an example configuration. Ethereum Options \u00b6 Ethereum chains support the following additional options: { \" bridge \" : \" 0x12345... \" , // Address of the bridge contract ( required ) \" erc20Handler \" : \" 0x1234... \" , // Address of erc20 handler \" erc721Handler \" : \" 0x1234... \" , // Address of erc721 handler \" genericHandler \" : \" 0x1234... \" , // Address of generic handler \" maxGasPrice \" : \" 0x1234 \" , // Gas price for transactions ( default : 20000000000 ) \" gasLimit \" : \" 0x1234 \" , // Gas limit for transactions ( default : 6721975 ) \" gasMultiplier \" : \" 1.25 \" , // Multiplies the gas price by the supplied value ( default : 1 ) \" http \" : \" true \" , // Whether the chain connection is ws or http ( default : false ) \" startBlock \" : \" 1234 \" , // The block to start processing events from ( default : 0 ) \" blockConfirmations \" : \" 10 \" // Number of blocks to wait before processing a block \" egsApiKey \" : \" xxx... \" // API key for Eth Gas Station ( https : // www . ethgasstation . info / ) \" egsSpeed \" : \" fast \" // Desired speed for gas price selection , the options are : \" average \" , \" fast \" , \" fastest \" } Substrate Options \u00b6 Substrate supports the following additonal options: { \" startBlock \" : \" 1234 \" // The block to start processing events from ( default : 0 ) \" useExtendedCall \" : \" true \" // Extend extrinsic calls to substrate with ResourceID . Used for backward compatibility with example pallet . } Blockstore \u00b6 The blockstore is used to record the last block the relayer processed, so it can pick up where it left off. If a startBlock option is provided (see Configuration ), then the greater of startBlock and the latest block in the blockstore is used at startup. To disable loading from the blockstore specify the --fresh flag. A custom path for the blockstore can be provided with --blockstore <path> . For development, the --latest flag can be used to start from the current block and override any other configuration. Keystore \u00b6 ChainBridge requires keys to sign and submit transactions, and to identify each bridge node on chain. To use secure keys, see chainbridge accounts --help . The keystore password can be supplied with the KEYSTORE_PASSWORD environment variable. To import external ethereum keys, such as those generated with geth, use chainbridge accounts import --ethereum /path/to/key . To import private keys as keystores, use chainbridge accounts import --privateKey key . For testing purposes, chainbridge provides 5 test keys. The can be used with --testkey <name> , where name is one of Alice , Bob , Charlie , Dave , or Eve .","title":"Overview"},{"location":"configuration/#configuration","text":"Note: TOML configs have been deprecated in favour of JSON A chain configurations take this form: { \"name\": \"eth\", // Human-readable name \"type\": \"ethereum\", // Chain type (eg. \"ethereum\" or \"substrate\") \"id\": \"0\", // Chain ID \"endpoint\": \"ws://<host>:<port>\", // Node endpoint \"from\": \"0xff93...\", // On-chain address of relayer \"opts\": {}, // Chain-specific configuration options (see below) } See config.json.example for an example configuration.","title":"Configuration"},{"location":"configuration/#ethereum-options","text":"Ethereum chains support the following additional options: { \" bridge \" : \" 0x12345... \" , // Address of the bridge contract ( required ) \" erc20Handler \" : \" 0x1234... \" , // Address of erc20 handler \" erc721Handler \" : \" 0x1234... \" , // Address of erc721 handler \" genericHandler \" : \" 0x1234... \" , // Address of generic handler \" maxGasPrice \" : \" 0x1234 \" , // Gas price for transactions ( default : 20000000000 ) \" gasLimit \" : \" 0x1234 \" , // Gas limit for transactions ( default : 6721975 ) \" gasMultiplier \" : \" 1.25 \" , // Multiplies the gas price by the supplied value ( default : 1 ) \" http \" : \" true \" , // Whether the chain connection is ws or http ( default : false ) \" startBlock \" : \" 1234 \" , // The block to start processing events from ( default : 0 ) \" blockConfirmations \" : \" 10 \" // Number of blocks to wait before processing a block \" egsApiKey \" : \" xxx... \" // API key for Eth Gas Station ( https : // www . ethgasstation . info / ) \" egsSpeed \" : \" fast \" // Desired speed for gas price selection , the options are : \" average \" , \" fast \" , \" fastest \" }","title":"Ethereum Options"},{"location":"configuration/#substrate-options","text":"Substrate supports the following additonal options: { \" startBlock \" : \" 1234 \" // The block to start processing events from ( default : 0 ) \" useExtendedCall \" : \" true \" // Extend extrinsic calls to substrate with ResourceID . Used for backward compatibility with example pallet . }","title":"Substrate Options"},{"location":"configuration/#blockstore","text":"The blockstore is used to record the last block the relayer processed, so it can pick up where it left off. If a startBlock option is provided (see Configuration ), then the greater of startBlock and the latest block in the blockstore is used at startup. To disable loading from the blockstore specify the --fresh flag. A custom path for the blockstore can be provided with --blockstore <path> . For development, the --latest flag can be used to start from the current block and override any other configuration.","title":"Blockstore"},{"location":"configuration/#keystore","text":"ChainBridge requires keys to sign and submit transactions, and to identify each bridge node on chain. To use secure keys, see chainbridge accounts --help . The keystore password can be supplied with the KEYSTORE_PASSWORD environment variable. To import external ethereum keys, such as those generated with geth, use chainbridge accounts import --ethereum /path/to/key . To import private keys as keystores, use chainbridge accounts import --privateKey key . For testing purposes, chainbridge provides 5 test keys. The can be used with --testkey <name> , where name is one of Alice , Bob , Charlie , Dave , or Eve .","title":"Keystore"},{"location":"faq/","text":"Where can I find help if I have further questions? \u00b6 You can join our Discord server. In case you have issues with bridge, feel free to create issue in github. Can you build an implementation for my project? \u00b6 We don't currently have capacity to build implementations of ChainBridge. However, you can jump into the relevant channel on our Discord to find other teams who want to work on the same implementation as you. Can you run a relayer for my project? \u00b6 Our focus right now is on building software to enable other teams to run bridges. At this time we are not looking to run relayers for any projects or bridge implementations. I need support to use/integrate with a specific ChainBridge implementation. \u00b6 While we are the developers of ChainBridge, we are not formally affiliated with any projects or bridge implementations. Please reach out to the relevant team/project for implementation-specific support. Avalanche: https://t.me/aebtechnicalsupport Expanse: https://discord.gg/DUN6r2X I want to try out ChainBridge locally, how can I do that? \u00b6 You can follow these instructions to run an Ethereum <> Substrate bridge locally https://chainbridge.chainsafe.io/local/ I'm having issues running ChainBridge with Ganache \u00b6 ChainBridge is not compatible with Ganache. Please try running Geth or any real node instead.","title":"FAQ"},{"location":"faq/#where-can-i-find-help-if-i-have-further-questions","text":"You can join our Discord server. In case you have issues with bridge, feel free to create issue in github.","title":"Where can I find help if I have further questions?"},{"location":"faq/#can-you-build-an-implementation-for-my-project","text":"We don't currently have capacity to build implementations of ChainBridge. However, you can jump into the relevant channel on our Discord to find other teams who want to work on the same implementation as you.","title":"Can you build an implementation for my project?"},{"location":"faq/#can-you-run-a-relayer-for-my-project","text":"Our focus right now is on building software to enable other teams to run bridges. At this time we are not looking to run relayers for any projects or bridge implementations.","title":"Can you run a relayer for my project?"},{"location":"faq/#i-need-support-to-useintegrate-with-a-specific-chainbridge-implementation","text":"While we are the developers of ChainBridge, we are not formally affiliated with any projects or bridge implementations. Please reach out to the relevant team/project for implementation-specific support. Avalanche: https://t.me/aebtechnicalsupport Expanse: https://discord.gg/DUN6r2X","title":"I need support to use/integrate with a specific ChainBridge implementation."},{"location":"faq/#i-want-to-try-out-chainbridge-locally-how-can-i-do-that","text":"You can follow these instructions to run an Ethereum <> Substrate bridge locally https://chainbridge.chainsafe.io/local/","title":"I want to try out ChainBridge locally, how can I do that?"},{"location":"faq/#im-having-issues-running-chainbridge-with-ganache","text":"ChainBridge is not compatible with Ganache. Please try running Geth or any real node instead.","title":"I'm having issues running ChainBridge with Ganache"},{"location":"installation/","text":"Installation \u00b6 Dependencies \u00b6 Subkey : Used for substrate key management. Only required if connecting to a substrate chain. make install-subkey Building from Source \u00b6 To build chainbridge in ./build . make build or Use go install to add chainbridge to your GOBIN. make install Docker \u00b6 The official ChainBridge Docker image can be found here . To build the Docker image locally run: docker build -t chainsafe/chainbridge . To start ChainBridge: docker run -v $(pwd)/config.json:/config.json chainsafe/chainbridge","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#dependencies","text":"Subkey : Used for substrate key management. Only required if connecting to a substrate chain. make install-subkey","title":"Dependencies"},{"location":"installation/#building-from-source","text":"To build chainbridge in ./build . make build or Use go install to add chainbridge to your GOBIN. make install","title":"Building from Source"},{"location":"installation/#docker","text":"The official ChainBridge Docker image can be found here . To build the Docker image locally run: docker build -t chainsafe/chainbridge . To start ChainBridge: docker run -v $(pwd)/config.json:/config.json chainsafe/chainbridge","title":"Docker"},{"location":"live-evm-bridge/","text":"Deploying a Live EVM->EVM Token Bridge \u00b6 This tutorial walks through the process of deploying a token exchange bridge between two Ethereum test networks (G\u00f6rli and Rinkeby). It could similarly be applied to link any two EVM-based chains including the Ethereum mainnet. At a high level setting up ChainBridge for token transfers requires the following: A token native to ChainA (e.g. TKN) and a destination token on ChainB which will represent the source token wrapped (e.g. wTKN) The ChainBridge bridge contract deployed to each chain Handler contracts on each chain to instruct the bridge what to do with the tokens One or more off-chain relayers running to pick up transactions from the source chain and relay them to the destination chain Overview of Cross-chain Token Transfers \u00b6 Tokens are inherently native to a single chain; however, with a bit of contract magic it is possible to make something equivalent to transferring value between two chains. Lock-and-Mint | Burn-and-Release \u00b6 This approach is appealing because it imposes very few requirements on the asset on the source chain other than it must be transferable and lockable in a contract. This makes it possible to use with native assets (e.g. ETH) or existing tokens that you don't control. The basic flow of lock-and-mint is as follows: Assets on the source chain are deposited in a bridge contract which locks them up A relayer observes this transaction and sends a new transaction to the bridge contract on the destination chain. This transaction should include a proof of the deposit on the source chain and a destination which is owned by the depositor The bridge contract mints new tokens on the destination chain into the depositors account on this chain It is important to notice that the total number of liquid (non-locked) tokens on both chains combined remains the same. Exchanging the tokens on the destination chain back to native tokens uses the inverse operation, burn-and-release. Tokens on the destination chain are sent to a bridge contract which burns them A relayer observes this transaction and sends a new transaction to the bridge contract on the source chain. This transaction should include a proof of the burn and a destination address The bridge contract unlocks some number of tokens and deposits them into the destination account Provided this refunding of tokens can be executed at any time and the number of locked tokens is always equal to the number of minted wrapped tokens, then we can say that the wrapped tokens have value equal to the original asset. ChainBridge Components \u00b6 A ChainBridge deployment on EVM-based chains requires the following components: Bridge Contract \u00b6 The bridge contract must be deployed on both the source and destination chains. Its primary task on the source chain is to broker token deposits (ensure they are locked) and emit the events that the relayers listen for. On the destination chain, the bridge contract is responsible for managing a set of permissioned relayers, aggregating relayer votes on proposals passed from the source chain, and executing the desired action (e.g. minting tokens) on the destination chain when the vote threshold is reached. Handlers \u00b6 To allow extensibility the bridge contract is written to call functions in a handler contract when tokens are deposited on the source chain or when a proposal is approved on the destination chain. Each resource (e.g. token) can have a unique handler. You are free to write your own handler contract that implements any functionality you like. The ERC20 handler contract that ships with ChainBridge can be configured to either lock up the tokens or burn them (if the token allows) on deposit and either mint or release tokens when a proposal is executed. A single handler can handle many tokens but their contract addresses must be registered with the handler ahead of time. Relayers \u00b6 The relayer is an off-chain actor that listens for particular events on the source chain and- when certain conditions are met- will submit signed proposals to the destination chain. The addresses of the approved relayers must be registered with the bridge contract on the destination chain. Once a proposal has sufficient votes a relayer can execute the proposal to trigger the handler. Deploying your own bridge \u00b6 Preparation \u00b6 Accounts \u00b6 If you want to follow along with this guide we will be deploying a bridge between two Ethereum test networks (G\u00f6rli and Rinkeby). You will need one account on each network from which to deploy the contracts. These can be easily created using MetaMask. Be careful to use test accounts only as some of the commands in this tutorial require access to your private key. This will cost gas so some test ETH will be required. So first up grab some test ether from the faucets: https://goerli-faucet.slock.it/ https://faucet.rinkeby.io/ You will need around 0.1 each of Goerli ETH and Rinkeby ETH. We will be creating a bridge that wraps the test ERC20 token WEENUS on G\u00f6rli as a wrapped version (wWEENUS) on Rinkeby. So also grab some free WEENUS tokens by sending a 0 ETH transaction to the contract address on G\u00f6rli: 0xaFF4481D10270F50f203E0763e2597776068CBc5 Tooling \u00b6 We will be using the ChainBridge contract CLI to deploy and interact with the contracts. Grab and install the CLI by running: git clone -b v1.0.0 --depth 1 https://github.com/ChainSafe/chainbridge-deploy \\ && cd chainbridge-deploy/cb-sol-cli \\ && npm install \\ && make install This will also download and build the required Solidity contracts. To avoid duplication in the subsequent commands set the following env vars in your shell: SRC_GATEWAY=https://goerli-light.eth.linkpool.io/ DST_GATEWAY=https://rinkeby-light.eth.linkpool.io/ SRC_ADDR=\"<Your public key on G\u00f6rli>\" SRC_PK=\"<your private key on G\u00f6rli>\" DST_ADDR=\"<Your public key on Rinkeby>\" DST_PK=\"<your private key on Rinkeby>\" SRC_TOKEN=\"0xaFF4481D10270F50f203E0763e2597776068CBc5\" RESOURCE_ID=\"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" You could also write the above to a file (e.g. chainbridge-vars ) and load it into your shell by running set -a; source ./chainbridge-vars; set +a . You can use MetaMask to generate new accounts on the test networks and export your public and private keys. Additional env vars are required to be set throughout the tutorial. If a command doesn't work be sure you have set the required variables. Steps \u00b6 1. Deploy contracts on Source (G\u00f6rli) \u00b6 The following command will deploy the bridge contract and ERC20 handler contract on the source. cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 deploy \\ --bridge --erc20Handler \\ --relayers $SRC_ADDR \\ --relayerThreshold 1 \\ --chainId 0 Take note of the output of the above command and assign the following variables. SRC_BRIDGE = \"<resulting bridge contract address>\" SRC_HANDLER = \"<resulting erc20 handler contract address>\" 2. Configure contracts on Source \u00b6 The following registers the WEENUS token as a resource with a bridge contract and configures which handler to use. cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 bridge register-resource \\ --bridge $SRC_BRIDGE \\ --handler $SRC_HANDLER \\ --resourceId $RESOURCE_ID \\ --targetContract $SRC_TOKEN Note: Sometimes the transaction confirmation will not be detected by the CLI. You can check the txhash in etherscan to see if it has been confirmed. 3. Deploy contracts on Destination (Rinkeby) \u00b6 The following command deploys the bridge contract, handler and a new ERC20 contract (wWEENUS) on the destination chain. It also configures your account as a verified relayer. cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 deploy \\ --bridge --erc20 --erc20Handler \\ --relayers $DST_ADDR \\ --relayerThreshold 1 \\ --chainId 1 Again, assign the following env variables. DST_BRIDGE = \"<resulting bridge contract address>\" DST_HANDLER = \"<resulting erc20 handler contract address>\" DST_TOKEN = \"<resulting erc20 token address>\" 4. Configure contracts on Destination \u00b6 The following registers the new token (wWEENUS) as a resource on the bridge similar to the above. cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 bridge register-resource \\ --bridge $DST_BRIDGE \\ --handler $DST_HANDLER \\ --resourceId $RESOURCE_ID \\ --targetContract $DST_TOKEN The following registers the token as mintable/burnable on the bridge. cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 bridge set-burn \\ --bridge $DST_BRIDGE \\ --handler $DST_HANDLER \\ --tokenContract $DST_TOKEN The following gives permission for the handler to mint new wWEENUS tokens. cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 erc20 add-minter \\ --minter $DST_HANDLER \\ --erc20Address $DST_TOKEN Create a Relayer \u00b6 With the above complete, the Ethereum side of the setup is finished. The only missing piece is a relayer to detect events on the source chain and submit them as proposals on the destination chain. In configuring the destination bridge contract we set the relayer threshold to 1, meaning only a single relayer must vote on a proposal for it to be approved. This is OK for testing but in practice a much larger set of relayers should be used with a suitable high threshold to make collusion difficult. 1. Build the relayer \u00b6 git clone -b v1.1.1 --depth 1 https://github.com/ChainSafe/chainbridge \\ && cd chainbridge \\ && make build 2. Author a config \u00b6 Execute the command below to create a config file with all the variables assigned in previous steps. echo \"{ \\\"chains\\\": [ { \\\"name\\\": \\\"Goerli\\\", \\\"type\\\": \\\"ethereum\\\", \\\"id\\\": \\\"0\\\", \\\"endpoint\\\": \\\"wss://goerli-light.eth.linkpool.io/ws\\\", \\\"from\\\": \\\" $SRC_ADDR \\\", \\\"opts\\\": { \\\"bridge\\\": \\\" $SRC_BRIDGE \\\", \\\"erc20Handler\\\": \\\" $SRC_HANDLER \\\", \\\"genericHandler\\\": \\\" $SRC_HANDLER \\\", \\\"gasLimit\\\": \\\"1000000\\\", \\\"maxGasPrice\\\": \\\"10000000000\\\" } }, { \\\"name\\\": \\\"Rinkeby\\\", \\\"type\\\": \\\"ethereum\\\", \\\"id\\\": \\\"1\\\", \\\"endpoint\\\": \\\"wss://rinkeby-light.eth.linkpool.io/ws\\\", \\\"from\\\": \\\" $DST_ADDR \\\", \\\"opts\\\": { \\\"bridge\\\": \\\" $DST_BRIDGE \\\", \\\"erc20Handler\\\": \\\" $DST_HANDLER \\\", \\\"genericHandler\\\": \\\" $DST_HANDLER \\\", \\\"gasLimit\\\": \\\"1000000\\\", \\\"maxGasPrice\\\": \\\"10000000000\\\" } } ] }\" >> config.json 3. Set up keys \u00b6 The relayer maintains its own keystore. To add a new account on the source and destination chains run: ./build/chainbridge accounts import --privateKey $SRC_PK ./build/chainbridge accounts import --privateKey $DST_PK Note: The second command might fail if you are using the same keys on both networks. That's OK just keep going Lets test our bridge! \u00b6 First start the relayer by running: ./build/chainbridge --config config.json --verbosity trace --latest The latest flag ensures that the relayer starts monitoring blocks from the most recent it can find and won't attempt to look through the history. Leave the relay running in a seperate shell while you run the commands below. Approve the handler to spend tokens on our behalf (to transfer them to the token safe). cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 erc20 approve \\ --amount 100 \\ --erc20Address $SRC_TOKEN \\ --recipient $SRC_HANDLER Note: Most ERC20 contracts use 18 decimal places. The amount specified will be encoded with the necessary decimal places. This can be configured with --decimals on the erc20 command. Execute a deposit. cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 erc20 deposit \\ --amount 100 \\ --dest 1 \\ --bridge $SRC_BRIDGE \\ --recipient $DST_ADDR \\ --resourceId $RESOURCE_ID The relayer will wait 10 block confirmations before submitting a request which may take a few minutes on the test network. Keep an eye on the target=XXXX output in the chainbridge relayer window. The transfer will occur when this reaches the block height of the deposit transaction. The relayer will show something similar to the below when it picks up a transaction and relays it. Some time later it will execute the proposal on the destination chain. When checking your balance for the token on the destination chain you should see the inbound tokens from the handler. Proposals will continue to be forwarded provided you keep the relayer process running. And back again! \u00b6 The bridge we've created already supports bi-directional transactions. We can submit a transaction to move tokens back from the destination to the source. Approve the handler on the destination chain to move tokens on our behalf (to burn them). cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 erc20 approve \\ --amount 1000000000000000000 \\ --erc20Address $DST_TOKEN \\ --recipient $DST_HANDLER Transfer the wrapped tokens back to the bridge. This should result in the locked tokens being freed on the source chain and returned to your account. cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 erc20 deposit \\ --amount 1000000000000000000 \\ --dest 0 \\ --bridge $DST_BRIDGE \\ --recipient $SRC_ADDR \\ --resourceId $RESOURCE_ID Closing thoughts \u00b6 It is also simple to extend the above to work with non-fungible assets (e.g. ERC721) by deploying another handler contract and reconfiguring the bridge. Of course having a single relayer is a highly centralised way to be running the bridge. With additional calls to add-relayer it is easy to set up extra accounts that can relay simultaneuosly. Once there are plenty of relayers you can increase the vote threshold so that a certain number of relayers need to agree on a proposal before it is executed. Read the documentation for the CLI tool to see how the bridge contract and handlers can be configured for different scenarios.","title":"Deploying Live (EVM <-> EVM)"},{"location":"live-evm-bridge/#deploying-a-live-evm-evm-token-bridge","text":"This tutorial walks through the process of deploying a token exchange bridge between two Ethereum test networks (G\u00f6rli and Rinkeby). It could similarly be applied to link any two EVM-based chains including the Ethereum mainnet. At a high level setting up ChainBridge for token transfers requires the following: A token native to ChainA (e.g. TKN) and a destination token on ChainB which will represent the source token wrapped (e.g. wTKN) The ChainBridge bridge contract deployed to each chain Handler contracts on each chain to instruct the bridge what to do with the tokens One or more off-chain relayers running to pick up transactions from the source chain and relay them to the destination chain","title":"Deploying a Live EVM-&gt;EVM Token Bridge"},{"location":"live-evm-bridge/#overview-of-cross-chain-token-transfers","text":"Tokens are inherently native to a single chain; however, with a bit of contract magic it is possible to make something equivalent to transferring value between two chains.","title":"Overview of Cross-chain Token Transfers"},{"location":"live-evm-bridge/#lock-and-mint-burn-and-release","text":"This approach is appealing because it imposes very few requirements on the asset on the source chain other than it must be transferable and lockable in a contract. This makes it possible to use with native assets (e.g. ETH) or existing tokens that you don't control. The basic flow of lock-and-mint is as follows: Assets on the source chain are deposited in a bridge contract which locks them up A relayer observes this transaction and sends a new transaction to the bridge contract on the destination chain. This transaction should include a proof of the deposit on the source chain and a destination which is owned by the depositor The bridge contract mints new tokens on the destination chain into the depositors account on this chain It is important to notice that the total number of liquid (non-locked) tokens on both chains combined remains the same. Exchanging the tokens on the destination chain back to native tokens uses the inverse operation, burn-and-release. Tokens on the destination chain are sent to a bridge contract which burns them A relayer observes this transaction and sends a new transaction to the bridge contract on the source chain. This transaction should include a proof of the burn and a destination address The bridge contract unlocks some number of tokens and deposits them into the destination account Provided this refunding of tokens can be executed at any time and the number of locked tokens is always equal to the number of minted wrapped tokens, then we can say that the wrapped tokens have value equal to the original asset.","title":"Lock-and-Mint | Burn-and-Release"},{"location":"live-evm-bridge/#chainbridge-components","text":"A ChainBridge deployment on EVM-based chains requires the following components:","title":"ChainBridge Components"},{"location":"live-evm-bridge/#bridge-contract","text":"The bridge contract must be deployed on both the source and destination chains. Its primary task on the source chain is to broker token deposits (ensure they are locked) and emit the events that the relayers listen for. On the destination chain, the bridge contract is responsible for managing a set of permissioned relayers, aggregating relayer votes on proposals passed from the source chain, and executing the desired action (e.g. minting tokens) on the destination chain when the vote threshold is reached.","title":"Bridge Contract"},{"location":"live-evm-bridge/#handlers","text":"To allow extensibility the bridge contract is written to call functions in a handler contract when tokens are deposited on the source chain or when a proposal is approved on the destination chain. Each resource (e.g. token) can have a unique handler. You are free to write your own handler contract that implements any functionality you like. The ERC20 handler contract that ships with ChainBridge can be configured to either lock up the tokens or burn them (if the token allows) on deposit and either mint or release tokens when a proposal is executed. A single handler can handle many tokens but their contract addresses must be registered with the handler ahead of time.","title":"Handlers"},{"location":"live-evm-bridge/#relayers","text":"The relayer is an off-chain actor that listens for particular events on the source chain and- when certain conditions are met- will submit signed proposals to the destination chain. The addresses of the approved relayers must be registered with the bridge contract on the destination chain. Once a proposal has sufficient votes a relayer can execute the proposal to trigger the handler.","title":"Relayers"},{"location":"live-evm-bridge/#deploying-your-own-bridge","text":"","title":"Deploying your own bridge"},{"location":"live-evm-bridge/#preparation","text":"","title":"Preparation"},{"location":"live-evm-bridge/#accounts","text":"If you want to follow along with this guide we will be deploying a bridge between two Ethereum test networks (G\u00f6rli and Rinkeby). You will need one account on each network from which to deploy the contracts. These can be easily created using MetaMask. Be careful to use test accounts only as some of the commands in this tutorial require access to your private key. This will cost gas so some test ETH will be required. So first up grab some test ether from the faucets: https://goerli-faucet.slock.it/ https://faucet.rinkeby.io/ You will need around 0.1 each of Goerli ETH and Rinkeby ETH. We will be creating a bridge that wraps the test ERC20 token WEENUS on G\u00f6rli as a wrapped version (wWEENUS) on Rinkeby. So also grab some free WEENUS tokens by sending a 0 ETH transaction to the contract address on G\u00f6rli: 0xaFF4481D10270F50f203E0763e2597776068CBc5","title":"Accounts"},{"location":"live-evm-bridge/#tooling","text":"We will be using the ChainBridge contract CLI to deploy and interact with the contracts. Grab and install the CLI by running: git clone -b v1.0.0 --depth 1 https://github.com/ChainSafe/chainbridge-deploy \\ && cd chainbridge-deploy/cb-sol-cli \\ && npm install \\ && make install This will also download and build the required Solidity contracts. To avoid duplication in the subsequent commands set the following env vars in your shell: SRC_GATEWAY=https://goerli-light.eth.linkpool.io/ DST_GATEWAY=https://rinkeby-light.eth.linkpool.io/ SRC_ADDR=\"<Your public key on G\u00f6rli>\" SRC_PK=\"<your private key on G\u00f6rli>\" DST_ADDR=\"<Your public key on Rinkeby>\" DST_PK=\"<your private key on Rinkeby>\" SRC_TOKEN=\"0xaFF4481D10270F50f203E0763e2597776068CBc5\" RESOURCE_ID=\"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" You could also write the above to a file (e.g. chainbridge-vars ) and load it into your shell by running set -a; source ./chainbridge-vars; set +a . You can use MetaMask to generate new accounts on the test networks and export your public and private keys. Additional env vars are required to be set throughout the tutorial. If a command doesn't work be sure you have set the required variables.","title":"Tooling"},{"location":"live-evm-bridge/#steps","text":"","title":"Steps"},{"location":"live-evm-bridge/#1-deploy-contracts-on-source-gorli","text":"The following command will deploy the bridge contract and ERC20 handler contract on the source. cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 deploy \\ --bridge --erc20Handler \\ --relayers $SRC_ADDR \\ --relayerThreshold 1 \\ --chainId 0 Take note of the output of the above command and assign the following variables. SRC_BRIDGE = \"<resulting bridge contract address>\" SRC_HANDLER = \"<resulting erc20 handler contract address>\"","title":"1. Deploy contracts on Source (G\u00f6rli)"},{"location":"live-evm-bridge/#2-configure-contracts-on-source","text":"The following registers the WEENUS token as a resource with a bridge contract and configures which handler to use. cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 bridge register-resource \\ --bridge $SRC_BRIDGE \\ --handler $SRC_HANDLER \\ --resourceId $RESOURCE_ID \\ --targetContract $SRC_TOKEN Note: Sometimes the transaction confirmation will not be detected by the CLI. You can check the txhash in etherscan to see if it has been confirmed.","title":"2. Configure contracts on Source"},{"location":"live-evm-bridge/#3-deploy-contracts-on-destination-rinkeby","text":"The following command deploys the bridge contract, handler and a new ERC20 contract (wWEENUS) on the destination chain. It also configures your account as a verified relayer. cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 deploy \\ --bridge --erc20 --erc20Handler \\ --relayers $DST_ADDR \\ --relayerThreshold 1 \\ --chainId 1 Again, assign the following env variables. DST_BRIDGE = \"<resulting bridge contract address>\" DST_HANDLER = \"<resulting erc20 handler contract address>\" DST_TOKEN = \"<resulting erc20 token address>\"","title":"3. Deploy contracts on Destination (Rinkeby)"},{"location":"live-evm-bridge/#4-configure-contracts-on-destination","text":"The following registers the new token (wWEENUS) as a resource on the bridge similar to the above. cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 bridge register-resource \\ --bridge $DST_BRIDGE \\ --handler $DST_HANDLER \\ --resourceId $RESOURCE_ID \\ --targetContract $DST_TOKEN The following registers the token as mintable/burnable on the bridge. cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 bridge set-burn \\ --bridge $DST_BRIDGE \\ --handler $DST_HANDLER \\ --tokenContract $DST_TOKEN The following gives permission for the handler to mint new wWEENUS tokens. cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 erc20 add-minter \\ --minter $DST_HANDLER \\ --erc20Address $DST_TOKEN","title":"4. Configure contracts on Destination"},{"location":"live-evm-bridge/#create-a-relayer","text":"With the above complete, the Ethereum side of the setup is finished. The only missing piece is a relayer to detect events on the source chain and submit them as proposals on the destination chain. In configuring the destination bridge contract we set the relayer threshold to 1, meaning only a single relayer must vote on a proposal for it to be approved. This is OK for testing but in practice a much larger set of relayers should be used with a suitable high threshold to make collusion difficult.","title":"Create a Relayer"},{"location":"live-evm-bridge/#1-build-the-relayer","text":"git clone -b v1.1.1 --depth 1 https://github.com/ChainSafe/chainbridge \\ && cd chainbridge \\ && make build","title":"1. Build the relayer"},{"location":"live-evm-bridge/#2-author-a-config","text":"Execute the command below to create a config file with all the variables assigned in previous steps. echo \"{ \\\"chains\\\": [ { \\\"name\\\": \\\"Goerli\\\", \\\"type\\\": \\\"ethereum\\\", \\\"id\\\": \\\"0\\\", \\\"endpoint\\\": \\\"wss://goerli-light.eth.linkpool.io/ws\\\", \\\"from\\\": \\\" $SRC_ADDR \\\", \\\"opts\\\": { \\\"bridge\\\": \\\" $SRC_BRIDGE \\\", \\\"erc20Handler\\\": \\\" $SRC_HANDLER \\\", \\\"genericHandler\\\": \\\" $SRC_HANDLER \\\", \\\"gasLimit\\\": \\\"1000000\\\", \\\"maxGasPrice\\\": \\\"10000000000\\\" } }, { \\\"name\\\": \\\"Rinkeby\\\", \\\"type\\\": \\\"ethereum\\\", \\\"id\\\": \\\"1\\\", \\\"endpoint\\\": \\\"wss://rinkeby-light.eth.linkpool.io/ws\\\", \\\"from\\\": \\\" $DST_ADDR \\\", \\\"opts\\\": { \\\"bridge\\\": \\\" $DST_BRIDGE \\\", \\\"erc20Handler\\\": \\\" $DST_HANDLER \\\", \\\"genericHandler\\\": \\\" $DST_HANDLER \\\", \\\"gasLimit\\\": \\\"1000000\\\", \\\"maxGasPrice\\\": \\\"10000000000\\\" } } ] }\" >> config.json","title":"2. Author a config"},{"location":"live-evm-bridge/#3-set-up-keys","text":"The relayer maintains its own keystore. To add a new account on the source and destination chains run: ./build/chainbridge accounts import --privateKey $SRC_PK ./build/chainbridge accounts import --privateKey $DST_PK Note: The second command might fail if you are using the same keys on both networks. That's OK just keep going","title":"3. Set up keys"},{"location":"live-evm-bridge/#lets-test-our-bridge","text":"First start the relayer by running: ./build/chainbridge --config config.json --verbosity trace --latest The latest flag ensures that the relayer starts monitoring blocks from the most recent it can find and won't attempt to look through the history. Leave the relay running in a seperate shell while you run the commands below. Approve the handler to spend tokens on our behalf (to transfer them to the token safe). cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 erc20 approve \\ --amount 100 \\ --erc20Address $SRC_TOKEN \\ --recipient $SRC_HANDLER Note: Most ERC20 contracts use 18 decimal places. The amount specified will be encoded with the necessary decimal places. This can be configured with --decimals on the erc20 command. Execute a deposit. cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 erc20 deposit \\ --amount 100 \\ --dest 1 \\ --bridge $SRC_BRIDGE \\ --recipient $DST_ADDR \\ --resourceId $RESOURCE_ID The relayer will wait 10 block confirmations before submitting a request which may take a few minutes on the test network. Keep an eye on the target=XXXX output in the chainbridge relayer window. The transfer will occur when this reaches the block height of the deposit transaction. The relayer will show something similar to the below when it picks up a transaction and relays it. Some time later it will execute the proposal on the destination chain. When checking your balance for the token on the destination chain you should see the inbound tokens from the handler. Proposals will continue to be forwarded provided you keep the relayer process running.","title":"Lets test our bridge!"},{"location":"live-evm-bridge/#and-back-again","text":"The bridge we've created already supports bi-directional transactions. We can submit a transaction to move tokens back from the destination to the source. Approve the handler on the destination chain to move tokens on our behalf (to burn them). cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 erc20 approve \\ --amount 1000000000000000000 \\ --erc20Address $DST_TOKEN \\ --recipient $DST_HANDLER Transfer the wrapped tokens back to the bridge. This should result in the locked tokens being freed on the source chain and returned to your account. cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 erc20 deposit \\ --amount 1000000000000000000 \\ --dest 0 \\ --bridge $DST_BRIDGE \\ --recipient $SRC_ADDR \\ --resourceId $RESOURCE_ID","title":"And back again!"},{"location":"live-evm-bridge/#closing-thoughts","text":"It is also simple to extend the above to work with non-fungible assets (e.g. ERC721) by deploying another handler contract and reconfiguring the bridge. Of course having a single relayer is a highly centralised way to be running the bridge. With additional calls to add-relayer it is easy to set up extra accounts that can relay simultaneuosly. Once there are plenty of relayers you can increase the vote threshold so that a certain number of relayers need to agree on a proposal before it is executed. Read the documentation for the CLI tool to see how the bridge contract and handlers can be configured for different scenarios.","title":"Closing thoughts"},{"location":"local/","text":"Running Locally \u00b6 Prerequisites \u00b6 Docker, docker-compose chainbridge v1.1.1 binary (see README ) cb-sol-cli (see README ) Steps To Get Started \u00b6 Start Local Chains Connect to PolkadotJS Portal Deploy Contracts Register Resources Ethereum Specify Token Semantics Register Relayers Register Resources Substrate Whitelist Chains Run Relayer Fungible Transfers Non-Fungible Transfers Start Local Chains \u00b6 The easiest way to get started is to use the below docker-compose snippet. This will start one geth instance and an instance of chainbridge-substrate-chain: # Copyright 2020 ChainSafe Systems # SPDX-License-Identifier: LGPL-3.0-only version : '3' services : geth1 : image : \"chainsafe/chainbridge-geth:20200505131100-5586a65\" container_name : geth1 ports : - \"8545:8545\" sub-chain : image : \"chainsafe/chainbridge-substrate-chain:v1.3.0\" container_name : sub-chain command : chainbridge-substrate-chain --dev --alice --ws-external --rpc-external ports : - \"9944:9944\" Start Chains: docker-compose -f docker-compose-snippet.yml up -V (Use -V to always start with new chains. These instructions depend on deterministic Ethereum addresses, which are used as defaults implicitly by some of these commands. Avoid re-deploying the contracts without restarting both chains, or ensure to specify all the required parameters.) Connect to PolkadotJS Portal \u00b6 Access the PolkadotJS Portal for Centrifuge, as an example Substrate chain, here Connect to your local Substrate chain: Click the network in the top-left corner Select the Development dropdown Set ws://localhost:9944 as the custom endpoint Click Switch to connect Set up type definitions for the chain: Navigate to Settings Select the Developer tab Paste in the below Type Defintions Save Type Defintions: { \"chainbridge::ChainId\" : \"u8\" , \"ChainId\" : \"u8\" , \"ResourceId\" : \"[u8; 32]\" , \"DepositNonce\" : \"u64\" , \"ProposalVotes\" : { \"votes_for\" : \"Vec<AccountId>\" , \"votes_against\" : \"Vec<AccountId>\" , \"status\" : \"enum\" }, \"Erc721Token\" : { \"id\" : \"TokenId\" , \"metadata\" : \"Vec<u8>\" }, \"TokenId\" : \"U256\" , \"Address\" : \"AccountId\" , \"LookupSource\" : \"AccountId\" } These can be found found here On-Chain Setup (Ethereum) \u00b6 Deploy Contracts \u00b6 To deploy the contracts on to the Ethereum chain, run the following: Deploy Contracts: cb-sol-cli deploy --all --relayerThreshold 1 After running, the expected output looks like this: ================================================================ Url: http://localhost:8545 Deployer: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Gas Limit: 8000000 Gas Price: 20000000 Deploy Cost: 0 .0 Options ======= Chain Id: 0 Threshold: 1 Relayers: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca,0x8e0a907331554AF72563Bd8D43051C2E64Be5d35,0x24962717f8fA5BA3b931bACaF9ac03924EB475a0,0x148FfB2074A9e59eD58142822b3eB3fcBffb0cd7,0x4CEEf6139f00F9F4535Ad19640Ff7A0137708485 Bridge Fee: 0 Expiry: 100 Contract Addresses ================================================================ Bridge: 0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B ---------------------------------------------------------------- Erc20 Handler: 0x3167776db165D8eA0f51790CA2bbf44Db5105ADF ---------------------------------------------------------------- Erc721 Handler: 0x3f709398808af36ADBA86ACC617FeB7F5B7B193E ---------------------------------------------------------------- Generic Handler: 0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07 ---------------------------------------------------------------- Erc20: 0x21605f71845f372A9ed84253d2D024B7B10999f4 ---------------------------------------------------------------- Erc721: 0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31 ---------------------------------------------------------------- Centrifuge Asset: Not Deployed ---------------------------------------------------------------- WETC: Not Deployed ================================================================ Register Resources Ethereum \u00b6 NOTE: The below registrations will not notify you upon successful completion. Register fungile resource ID with erc20 contract: cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" --targetContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" Register non-fungible resource ID with erc721 contract: cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --targetContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" Register generic resource ID: cb-sol-cli bridge register-generic-resource --resourceId \"0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01\" --targetContract \"0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4\" --handler \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" --hash --deposit \"\" --execute \"store(bytes32)\" Specify Token Semantics \u00b6 To allow for a variety of use cases, the Ethereum contracts support both the transfer and the mint/burn ERC methods. For simplicity's sake the following examples only make use of the mint/burn method: Register the erc20 contract as mintable/burnable: cb-sol-cli bridge set-burn --tokenContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" Register the associated handler as a minter: cb-sol-cli erc20 add-minter --minter \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" Register the erc721 contract as mintable/burnable: cb-sol-cli bridge set-burn --tokenContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" Add the handler as a minter: cb-sol-cli erc721 add-minter --minter \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" On-Chain Setup (Substrate) \u00b6 Register Relayers \u00b6 First, we need to register the account of the relayer on Substrate (cb-sol-cli deploys contracts with the 5 test keys preloaded). Steps to register the relayers: Select the Sudo tab in the PolkadotJS Portal Choose the addRelayer method of chainBridge Select Alice as the relayer AccountId Register Resources Substrate \u00b6 Steps to register resources: Select the Sudo tab in the PolkadotJS Portal Call chainBridge.setResource , passing both the Id and Method listed below for each of the transfer types you wish to use Fungible (Native asset): Id: 0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00 Method: 0x4578616d706c652e7472616e73666572 (utf-8 encoding of \"Example.transfer\") NonFungible(ERC721): Id: 0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501 Method: 0x4578616d706c652e6d696e745f657263373231 (utf-8 encoding of \"Example.mint_erc721\") Generic (Hash Transfer): Id: 0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01 Method: 0x4578616d706c652e72656d61726b (utf-8 encoding of \"Example.remark\") Whitelist Chains \u00b6 Steps to whitelist chains: Select the Sudo tab in the PolkadotJS Portal Call chainBridge.whitelistChain , specifying 0 for the Ethereum chain ID Run Relayer \u00b6 Steps to run a relayer: Clone the ChainBridge repository Install the ChainBridge binary Create config.json using the sample provided below as a starting point Start relayer as a binary using the default \"Alice\" key Clone repo: git clone git@github.com:ChainSafe/ChainBridge.git Build ChainBridge and move it to your GOBIN path: cd ChainBridge && make install Run relayer : chainbridge --config config.json --testkey alice --latest Or, if you prefer Docker, steps 2 and 4 can be done as follows: Build the ChainBridge docker image: docker build -t chainsafe/chainbridge . Start the relayer as a docker container: docker run -v ( pwd ) /config.json:/config.json --network host chainsafe/chainbridge --testkey alice --latest Sample config.json : { \"chains\" : [ { \"name\" : \"eth\" , \"type\" : \"ethereum\" , \"id\" : \"0\" , \"endpoint\" : \"ws://localhost:8545\" , \"from\" : \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\" , \"opts\" : { \"bridge\" : \"0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B\" , \"erc20Handler\" : \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" , \"erc721Handler\" : \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" , \"genericHandler\" : \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" , \"gasLimit\" : \"1000000\" , \"maxGasPrice\" : \"20000000\" } }, { \"name\" : \"sub\" , \"type\" : \"substrate\" , \"id\" : \"1\" , \"endpoint\" : \"ws://localhost:9944\" , \"from\" : \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\" , \"opts\" : { \"useExtendedCall\" : \"true\" } } ] } This is an example config file for a single relayer (\"Alice\") using the contracts we've deployed. Fungible Transfers \u00b6 Substrate Native Token \u21d2 ERC 20 \u00b6 Steps to transfer an ERC-20 token: Select the Extrinsics tab in the PolkadotJS Portal Call example.transferNative with parameters such as these: Amount: 1000 (select Pico for units) Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Dest Id: 0 You can query the recipients balance on Ethereum with this: Query token balance of account: Oxff..750Ca : cb-sol-cli erc20 balance --address \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\" ERC20 \u21d2 Substrate Native Token \u00b6 If necessary, you can mint some tokens: Mint 1000 ERC20 tokens : cb-sol-cli erc20 mint --amount 1000 Before initiating the transfer we have to approve the bridge to take ownership of the tokens: Approve bridge to assume custody of tokens: cb-sol-cli erc20 approve --amount 1000 --recipient \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" To initiate a transfer on the Ethereum chain use this command (Note: there will be a 10 block delay before the relayer will process the transfer): Transfer 1 token to account: 0xd4..da27d : cb-sol-cli erc20 deposit --amount 1 --dest 1 --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\" --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" Non-Fungible Transfers \u00b6 Substrate NFT \u21d2 ERC721 \u00b6 First, you'll need to mint a token. Steps to mint an ERC-721 token: Select the Sudo tab in the PolkadotJS Portal Call erc721.mint with parameters such as these: Owner: Alice TokenId: 1 Metadata: \"\" Now the owner of the token can initiate a transfer. Steps to transfer an ERC-721 token: Select the Sudo tab in the PolkadotJS Portal Call example.transferErc721 with parameters such as these: Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca TokenId: 1 DestId: 0 You can query ownership of tokens on Ethereum with this: Query ownership of ERC721 with token ID: 1 : cb-sol-cli erc721 owner --id 0x1 ERC721 \u21d2 Substrate NFT \u00b6 If necessary, you can mint an ERC-721 token like this: Mint ERC721 with token ID: 99 : cb-sol-cli erc721 mint --id 0x99 Before initiating the transfer, we must approve the bridge to take ownership of the tokens: Approve bridge to assume custody of ERC721 with token ID: 99 : cb-sol-cli erc721 approve --id 0x99 --recipient \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" Now we can initiate the transfer: Transfer ERC721 with token ID: 99 to account: 0xd4..da27d : cb-sol-cli erc721 deposit --id 0x99 --dest 1 --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\" Generic Data Transfer \u00b6 To demonstrate a possible use of the generic data transfer, we have a hash registry on Ethereum. We also have a method on the example Substrate chain to emit a hash inside an event, which we can trigger from Ethereum. Generic Data Substrate \u21d2 Eth \u00b6 For this example we will transfer a 32 byte hash to a registry on Ethereum. Steps to transfer data to Ethereum: Select the Extrinsics tab in the PolkadotJS Portal Call example.transferHash with parameters such as these: Hash: 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730 Dest ID: 0 You can verify the transfer with this command: Verify transfer of hash : cb-sol-cli cent getHash --hash 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730","title":"Running Locally (EVM <-> Substrate)"},{"location":"local/#running-locally","text":"","title":"Running Locally"},{"location":"local/#prerequisites","text":"Docker, docker-compose chainbridge v1.1.1 binary (see README ) cb-sol-cli (see README )","title":"Prerequisites"},{"location":"local/#steps-to-get-started","text":"Start Local Chains Connect to PolkadotJS Portal Deploy Contracts Register Resources Ethereum Specify Token Semantics Register Relayers Register Resources Substrate Whitelist Chains Run Relayer Fungible Transfers Non-Fungible Transfers","title":"Steps To Get Started"},{"location":"local/#start-local-chains","text":"The easiest way to get started is to use the below docker-compose snippet. This will start one geth instance and an instance of chainbridge-substrate-chain: # Copyright 2020 ChainSafe Systems # SPDX-License-Identifier: LGPL-3.0-only version : '3' services : geth1 : image : \"chainsafe/chainbridge-geth:20200505131100-5586a65\" container_name : geth1 ports : - \"8545:8545\" sub-chain : image : \"chainsafe/chainbridge-substrate-chain:v1.3.0\" container_name : sub-chain command : chainbridge-substrate-chain --dev --alice --ws-external --rpc-external ports : - \"9944:9944\" Start Chains: docker-compose -f docker-compose-snippet.yml up -V (Use -V to always start with new chains. These instructions depend on deterministic Ethereum addresses, which are used as defaults implicitly by some of these commands. Avoid re-deploying the contracts without restarting both chains, or ensure to specify all the required parameters.)","title":"Start Local Chains"},{"location":"local/#connect-to-polkadotjs-portal","text":"Access the PolkadotJS Portal for Centrifuge, as an example Substrate chain, here Connect to your local Substrate chain: Click the network in the top-left corner Select the Development dropdown Set ws://localhost:9944 as the custom endpoint Click Switch to connect Set up type definitions for the chain: Navigate to Settings Select the Developer tab Paste in the below Type Defintions Save Type Defintions: { \"chainbridge::ChainId\" : \"u8\" , \"ChainId\" : \"u8\" , \"ResourceId\" : \"[u8; 32]\" , \"DepositNonce\" : \"u64\" , \"ProposalVotes\" : { \"votes_for\" : \"Vec<AccountId>\" , \"votes_against\" : \"Vec<AccountId>\" , \"status\" : \"enum\" }, \"Erc721Token\" : { \"id\" : \"TokenId\" , \"metadata\" : \"Vec<u8>\" }, \"TokenId\" : \"U256\" , \"Address\" : \"AccountId\" , \"LookupSource\" : \"AccountId\" } These can be found found here","title":"Connect to PolkadotJS Portal"},{"location":"local/#on-chain-setup-ethereum","text":"","title":"On-Chain Setup (Ethereum)"},{"location":"local/#deploy-contracts","text":"To deploy the contracts on to the Ethereum chain, run the following: Deploy Contracts: cb-sol-cli deploy --all --relayerThreshold 1 After running, the expected output looks like this: ================================================================ Url: http://localhost:8545 Deployer: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Gas Limit: 8000000 Gas Price: 20000000 Deploy Cost: 0 .0 Options ======= Chain Id: 0 Threshold: 1 Relayers: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca,0x8e0a907331554AF72563Bd8D43051C2E64Be5d35,0x24962717f8fA5BA3b931bACaF9ac03924EB475a0,0x148FfB2074A9e59eD58142822b3eB3fcBffb0cd7,0x4CEEf6139f00F9F4535Ad19640Ff7A0137708485 Bridge Fee: 0 Expiry: 100 Contract Addresses ================================================================ Bridge: 0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B ---------------------------------------------------------------- Erc20 Handler: 0x3167776db165D8eA0f51790CA2bbf44Db5105ADF ---------------------------------------------------------------- Erc721 Handler: 0x3f709398808af36ADBA86ACC617FeB7F5B7B193E ---------------------------------------------------------------- Generic Handler: 0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07 ---------------------------------------------------------------- Erc20: 0x21605f71845f372A9ed84253d2D024B7B10999f4 ---------------------------------------------------------------- Erc721: 0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31 ---------------------------------------------------------------- Centrifuge Asset: Not Deployed ---------------------------------------------------------------- WETC: Not Deployed ================================================================","title":"Deploy Contracts"},{"location":"local/#register-resources-ethereum","text":"NOTE: The below registrations will not notify you upon successful completion. Register fungile resource ID with erc20 contract: cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" --targetContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" Register non-fungible resource ID with erc721 contract: cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --targetContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" Register generic resource ID: cb-sol-cli bridge register-generic-resource --resourceId \"0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01\" --targetContract \"0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4\" --handler \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" --hash --deposit \"\" --execute \"store(bytes32)\"","title":"Register Resources Ethereum"},{"location":"local/#specify-token-semantics","text":"To allow for a variety of use cases, the Ethereum contracts support both the transfer and the mint/burn ERC methods. For simplicity's sake the following examples only make use of the mint/burn method: Register the erc20 contract as mintable/burnable: cb-sol-cli bridge set-burn --tokenContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\" Register the associated handler as a minter: cb-sol-cli erc20 add-minter --minter \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" Register the erc721 contract as mintable/burnable: cb-sol-cli bridge set-burn --tokenContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" Add the handler as a minter: cb-sol-cli erc721 add-minter --minter \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\"","title":"Specify Token Semantics"},{"location":"local/#on-chain-setup-substrate","text":"","title":"On-Chain Setup (Substrate)"},{"location":"local/#register-relayers","text":"First, we need to register the account of the relayer on Substrate (cb-sol-cli deploys contracts with the 5 test keys preloaded). Steps to register the relayers: Select the Sudo tab in the PolkadotJS Portal Choose the addRelayer method of chainBridge Select Alice as the relayer AccountId","title":"Register Relayers"},{"location":"local/#register-resources-substrate","text":"Steps to register resources: Select the Sudo tab in the PolkadotJS Portal Call chainBridge.setResource , passing both the Id and Method listed below for each of the transfer types you wish to use Fungible (Native asset): Id: 0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00 Method: 0x4578616d706c652e7472616e73666572 (utf-8 encoding of \"Example.transfer\") NonFungible(ERC721): Id: 0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501 Method: 0x4578616d706c652e6d696e745f657263373231 (utf-8 encoding of \"Example.mint_erc721\") Generic (Hash Transfer): Id: 0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01 Method: 0x4578616d706c652e72656d61726b (utf-8 encoding of \"Example.remark\")","title":"Register Resources Substrate"},{"location":"local/#whitelist-chains","text":"Steps to whitelist chains: Select the Sudo tab in the PolkadotJS Portal Call chainBridge.whitelistChain , specifying 0 for the Ethereum chain ID","title":"Whitelist Chains"},{"location":"local/#run-relayer","text":"Steps to run a relayer: Clone the ChainBridge repository Install the ChainBridge binary Create config.json using the sample provided below as a starting point Start relayer as a binary using the default \"Alice\" key Clone repo: git clone git@github.com:ChainSafe/ChainBridge.git Build ChainBridge and move it to your GOBIN path: cd ChainBridge && make install Run relayer : chainbridge --config config.json --testkey alice --latest Or, if you prefer Docker, steps 2 and 4 can be done as follows: Build the ChainBridge docker image: docker build -t chainsafe/chainbridge . Start the relayer as a docker container: docker run -v ( pwd ) /config.json:/config.json --network host chainsafe/chainbridge --testkey alice --latest Sample config.json : { \"chains\" : [ { \"name\" : \"eth\" , \"type\" : \"ethereum\" , \"id\" : \"0\" , \"endpoint\" : \"ws://localhost:8545\" , \"from\" : \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\" , \"opts\" : { \"bridge\" : \"0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B\" , \"erc20Handler\" : \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" , \"erc721Handler\" : \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" , \"genericHandler\" : \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" , \"gasLimit\" : \"1000000\" , \"maxGasPrice\" : \"20000000\" } }, { \"name\" : \"sub\" , \"type\" : \"substrate\" , \"id\" : \"1\" , \"endpoint\" : \"ws://localhost:9944\" , \"from\" : \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\" , \"opts\" : { \"useExtendedCall\" : \"true\" } } ] } This is an example config file for a single relayer (\"Alice\") using the contracts we've deployed.","title":"Run Relayer"},{"location":"local/#fungible-transfers","text":"","title":"Fungible Transfers"},{"location":"local/#substrate-native-token-erc-20","text":"Steps to transfer an ERC-20 token: Select the Extrinsics tab in the PolkadotJS Portal Call example.transferNative with parameters such as these: Amount: 1000 (select Pico for units) Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca Dest Id: 0 You can query the recipients balance on Ethereum with this: Query token balance of account: Oxff..750Ca : cb-sol-cli erc20 balance --address \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\"","title":"Substrate Native Token \u21d2 ERC 20"},{"location":"local/#erc20-substrate-native-token","text":"If necessary, you can mint some tokens: Mint 1000 ERC20 tokens : cb-sol-cli erc20 mint --amount 1000 Before initiating the transfer we have to approve the bridge to take ownership of the tokens: Approve bridge to assume custody of tokens: cb-sol-cli erc20 approve --amount 1000 --recipient \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\" To initiate a transfer on the Ethereum chain use this command (Note: there will be a 10 block delay before the relayer will process the transfer): Transfer 1 token to account: 0xd4..da27d : cb-sol-cli erc20 deposit --amount 1 --dest 1 --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\" --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\"","title":"ERC20 \u21d2 Substrate Native Token"},{"location":"local/#non-fungible-transfers","text":"","title":"Non-Fungible Transfers"},{"location":"local/#substrate-nft-erc721","text":"First, you'll need to mint a token. Steps to mint an ERC-721 token: Select the Sudo tab in the PolkadotJS Portal Call erc721.mint with parameters such as these: Owner: Alice TokenId: 1 Metadata: \"\" Now the owner of the token can initiate a transfer. Steps to transfer an ERC-721 token: Select the Sudo tab in the PolkadotJS Portal Call example.transferErc721 with parameters such as these: Recipient: 0xff93B45308FD417dF303D6515aB04D9e89a750Ca TokenId: 1 DestId: 0 You can query ownership of tokens on Ethereum with this: Query ownership of ERC721 with token ID: 1 : cb-sol-cli erc721 owner --id 0x1","title":"Substrate NFT \u21d2 ERC721"},{"location":"local/#erc721-substrate-nft","text":"If necessary, you can mint an ERC-721 token like this: Mint ERC721 with token ID: 99 : cb-sol-cli erc721 mint --id 0x99 Before initiating the transfer, we must approve the bridge to take ownership of the tokens: Approve bridge to assume custody of ERC721 with token ID: 99 : cb-sol-cli erc721 approve --id 0x99 --recipient \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\" Now we can initiate the transfer: Transfer ERC721 with token ID: 99 to account: 0xd4..da27d : cb-sol-cli erc721 deposit --id 0x99 --dest 1 --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\"","title":"ERC721 \u21d2 Substrate NFT"},{"location":"local/#generic-data-transfer","text":"To demonstrate a possible use of the generic data transfer, we have a hash registry on Ethereum. We also have a method on the example Substrate chain to emit a hash inside an event, which we can trigger from Ethereum.","title":"Generic Data Transfer"},{"location":"local/#generic-data-substrate-eth","text":"For this example we will transfer a 32 byte hash to a registry on Ethereum. Steps to transfer data to Ethereum: Select the Extrinsics tab in the PolkadotJS Portal Call example.transferHash with parameters such as these: Hash: 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730 Dest ID: 0 You can verify the transfer with this command: Verify transfer of hash : cb-sol-cli cent getHash --hash 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730","title":"Generic Data Substrate \u21d2 Eth"},{"location":"metrics/","text":"Metrics \u00b6 Basic metrics and a health status check can be enabled with the --metrics flag (default port 8001 , use --metricsPort to specify). Prometheus \u00b6 Prometheus metrics are served on /metrics . For each chain that exists, this provides: - <chain>_blocks_processed : the number of blocks processed by the chains listener. - <chain>_latest_processed_block : most recent block that has been processed by the listener. - <chain>_latest_known_block : most recent block that exists on the chain. - <chain>_votes_submitted : number of votes submitted by the relayer. Health Check \u00b6 The endpoint /health will return the current known block height, and a timestamp of when it was first seen for every chain: ```json { \"chains\": [ { \"chainId\": \"Number\", \"height\": \"Number\", \"lastUpdated\": \"Date\" } ] } If the timestamp is at least 120 seconds old an error will be returned instead : ``` json { \" error \" : \" String \" }","title":"Metrics"},{"location":"metrics/#metrics","text":"Basic metrics and a health status check can be enabled with the --metrics flag (default port 8001 , use --metricsPort to specify).","title":"Metrics"},{"location":"metrics/#prometheus","text":"Prometheus metrics are served on /metrics . For each chain that exists, this provides: - <chain>_blocks_processed : the number of blocks processed by the chains listener. - <chain>_latest_processed_block : most recent block that has been processed by the listener. - <chain>_latest_known_block : most recent block that exists on the chain. - <chain>_votes_submitted : number of votes submitted by the relayer.","title":"Prometheus"},{"location":"metrics/#health-check","text":"The endpoint /health will return the current known block height, and a timestamp of when it was first seen for every chain: ```json { \"chains\": [ { \"chainId\": \"Number\", \"height\": \"Number\", \"lastUpdated\": \"Date\" } ] } If the timestamp is at least 120 seconds old an error will be returned instead : ``` json { \" error \" : \" String \" }","title":"Health Check"},{"location":"spec/","text":"ChainBridge Specification \u00b6 Summary \u00b6 ChainBridge is a modular multi-directional blockchain bridge to allow data and value transfer between any number of blockchains. This should enable users to specify a destination blockchain from their source chain, and send data to that blockchain for consumption on the destination chain. This could be a token that is locked on ChainA and redeemed on ChainB, or an operation that is executed on a destination chain and initiated on the source chain. The bridge should maintain a set of relayers that are authorized to make & process transfers across the different blockchains. The bridge design should be modular enough that the addition of a new type of transfer should not require a full re-deployment of the suite of tools, rather small modular upgrades. Definitions \u00b6 Chain ID \u00b6 Each chain has a unique 8-bit identifier. We presently define the following chain IDs (subject to change): ID Chain 0 ETH Mainnet 1 ETC Mainnet 2 Centrifuge Network 3 Aragon Chain .. .. Deposit Nonce \u00b6 A nonce must be generated for every transfer to ensure uniqueness. All implementations must track a sequential nonce (unsigned 64-bit integer) for each possible destination chain. This is included as a standard parameter for each transfer. Order is not enforced. Resource ID \u00b6 In order to provide generality, we need some way to associate some action on a source chain to some action on a destination chain. This may express tokenX on chain A is equivalent to tokenY on chain B, or to simply associate that some action performed on chain A should result in some other action occurring on chain B. All resource IDs are considered to have a Home Chain. The only strict requirements for Resource IDs is that they must be 32 bytes in length and the least significant byte must contain a chain ID. Resource IDs are arbitrary, you can use anything you like. The resource ID should be the same on every chain for the same token. One convention is use 0x0... to indicate where the token originates from. You would use a different resource ID from each token that is supported, or for any arbitrary action via the generic handler. The format is just a suggestion, and the chain ID included is in reference to the origin chain where the token was first created. Transfer Flow \u00b6 User initiates a transfer on the source chain. Relayers observing the chain parse the parameters of the transfer and format them into a message. The message is parsed and then proposed on the destination chain. If the vote threshold is met, the proposal will be executed to finalize the transfer. After the initiation, a user should not be required to make any additional interactions. Transfer Types \u00b6 In a effort to balance the goals of allowing simple integration and proving generalized transfers, multiple transfer types are defined. Some or all of these may implemented for a chain. Event Description FungibleTransfer Transfer of fungible assets NonFungibleTransfer Transfer of non-fungible assets GenericTransfer Transfer of arbitrary data All transfers contain a source chain, destination chain, deposit nonce, resource ID and transfer-specific parameters. Fungible \u00b6 Field Type Description Amount 256 bit uint The total number of assets being transferred Recipient 32 bytes The recipient address on the destination chain Non-Fungible \u00b6 Field Type Description Token ID 256 bit uint The unique identifier for the NFT Recipient 32 bytes The recipient address on the destination chain Metadata variable sized bytes Any additional data associated to the NFT Generic \u00b6 Field Type Description Metadata variable sized bytes An opaque payload to transmit Note: Addresses are limited to 32bytes in size, but may be smaller. They must always be compatible with the destination chain. Relayer Set \u00b6 Each chain implementation must track a set of relayers, and allow updating of the set as necessary. A threshold should also be maintained to define how many relayers must vote for a proposed transfer before is can be executed. For this initial implementation, the relayer set may be controlled by a single party. Multi-signature wallets can be used to distribute risk, if available on the chain. Implementation \u00b6 This sections defines the specifics of the ChainBridge implementation and the requirements for a chain integration. Components \u00b6 Chain \u00b6 A chain is loosely defined as consisting of three major components: Connection : A container for on chain interactions. Shared by the listener and writer. Listener : Observes chain state transitions to watch for initiated transfers. When a transfer is encountered it should construct a message and pass it to the router. Writer : Responsible for performing on-chain actions. This will parse a proposed transfer from a message and enact it on-chain. These vary considerably depending on the chain. As long as the on-chain components are compatible, following the internal message protocol should be sufficient to be compatible with the system. These components are intended for architectural guidance and are only loosely constrained. Message \u00b6 A message represents a single transfer and its associated parameters. type Message struct { Source ChainId Destination ChainId Type TransferType DepositNonce Nonce ResourceId ResourceId Payload [] interface {} } The payload field contains the data for the specific transfer, as defined above . Router \u00b6 The router is responsible for taking messages from a source chain and routing them to their destination chain. The router provides an interface to allow Listeners to submit constructed messages: type Router interface { Send ( message msg . Message ) error } All chains must fulfill a Writer interface to receive messages from the router: type Writer interface { ResolveMessage ( message msg . Message ) bool }","title":"ChainBridge"},{"location":"spec/#chainbridge-specification","text":"","title":"ChainBridge Specification"},{"location":"spec/#summary","text":"ChainBridge is a modular multi-directional blockchain bridge to allow data and value transfer between any number of blockchains. This should enable users to specify a destination blockchain from their source chain, and send data to that blockchain for consumption on the destination chain. This could be a token that is locked on ChainA and redeemed on ChainB, or an operation that is executed on a destination chain and initiated on the source chain. The bridge should maintain a set of relayers that are authorized to make & process transfers across the different blockchains. The bridge design should be modular enough that the addition of a new type of transfer should not require a full re-deployment of the suite of tools, rather small modular upgrades.","title":"Summary"},{"location":"spec/#definitions","text":"","title":"Definitions"},{"location":"spec/#chain-id","text":"Each chain has a unique 8-bit identifier. We presently define the following chain IDs (subject to change): ID Chain 0 ETH Mainnet 1 ETC Mainnet 2 Centrifuge Network 3 Aragon Chain .. ..","title":"Chain ID"},{"location":"spec/#deposit-nonce","text":"A nonce must be generated for every transfer to ensure uniqueness. All implementations must track a sequential nonce (unsigned 64-bit integer) for each possible destination chain. This is included as a standard parameter for each transfer. Order is not enforced.","title":"Deposit Nonce"},{"location":"spec/#resource-id","text":"In order to provide generality, we need some way to associate some action on a source chain to some action on a destination chain. This may express tokenX on chain A is equivalent to tokenY on chain B, or to simply associate that some action performed on chain A should result in some other action occurring on chain B. All resource IDs are considered to have a Home Chain. The only strict requirements for Resource IDs is that they must be 32 bytes in length and the least significant byte must contain a chain ID. Resource IDs are arbitrary, you can use anything you like. The resource ID should be the same on every chain for the same token. One convention is use 0x0... to indicate where the token originates from. You would use a different resource ID from each token that is supported, or for any arbitrary action via the generic handler. The format is just a suggestion, and the chain ID included is in reference to the origin chain where the token was first created.","title":"Resource ID"},{"location":"spec/#transfer-flow","text":"User initiates a transfer on the source chain. Relayers observing the chain parse the parameters of the transfer and format them into a message. The message is parsed and then proposed on the destination chain. If the vote threshold is met, the proposal will be executed to finalize the transfer. After the initiation, a user should not be required to make any additional interactions.","title":"Transfer Flow"},{"location":"spec/#transfer-types","text":"In a effort to balance the goals of allowing simple integration and proving generalized transfers, multiple transfer types are defined. Some or all of these may implemented for a chain. Event Description FungibleTransfer Transfer of fungible assets NonFungibleTransfer Transfer of non-fungible assets GenericTransfer Transfer of arbitrary data All transfers contain a source chain, destination chain, deposit nonce, resource ID and transfer-specific parameters.","title":"Transfer Types"},{"location":"spec/#fungible","text":"Field Type Description Amount 256 bit uint The total number of assets being transferred Recipient 32 bytes The recipient address on the destination chain","title":"Fungible"},{"location":"spec/#non-fungible","text":"Field Type Description Token ID 256 bit uint The unique identifier for the NFT Recipient 32 bytes The recipient address on the destination chain Metadata variable sized bytes Any additional data associated to the NFT","title":"Non-Fungible"},{"location":"spec/#generic","text":"Field Type Description Metadata variable sized bytes An opaque payload to transmit Note: Addresses are limited to 32bytes in size, but may be smaller. They must always be compatible with the destination chain.","title":"Generic"},{"location":"spec/#relayer-set","text":"Each chain implementation must track a set of relayers, and allow updating of the set as necessary. A threshold should also be maintained to define how many relayers must vote for a proposed transfer before is can be executed. For this initial implementation, the relayer set may be controlled by a single party. Multi-signature wallets can be used to distribute risk, if available on the chain.","title":"Relayer Set"},{"location":"spec/#implementation","text":"This sections defines the specifics of the ChainBridge implementation and the requirements for a chain integration.","title":"Implementation"},{"location":"spec/#components","text":"","title":"Components"},{"location":"spec/#chain","text":"A chain is loosely defined as consisting of three major components: Connection : A container for on chain interactions. Shared by the listener and writer. Listener : Observes chain state transitions to watch for initiated transfers. When a transfer is encountered it should construct a message and pass it to the router. Writer : Responsible for performing on-chain actions. This will parse a proposed transfer from a message and enact it on-chain. These vary considerably depending on the chain. As long as the on-chain components are compatible, following the internal message protocol should be sufficient to be compatible with the system. These components are intended for architectural guidance and are only loosely constrained.","title":"Chain"},{"location":"spec/#message","text":"A message represents a single transfer and its associated parameters. type Message struct { Source ChainId Destination ChainId Type TransferType DepositNonce Nonce ResourceId ResourceId Payload [] interface {} } The payload field contains the data for the specific transfer, as defined above .","title":"Message"},{"location":"spec/#router","text":"The router is responsible for taking messages from a source chain and routing them to their destination chain. The router provides an interface to allow Listeners to submit constructed messages: type Router interface { Send ( message msg . Message ) error } All chains must fulfill a Writer interface to receive messages from the router: type Writer interface { ResolveMessage ( message msg . Message ) bool }","title":"Router"},{"location":"test/","text":"Testing \u00b6 Unit tests require an ethereum node running on localhost:8545 and a substrate node running on localhost:9944 . E2E tests require an additional ethereum node on localhost:8546 . A docker-compose file is provided to run two Geth nodes and a chainbridge-substrate-chain node in isolated environments: $ docker-compose -f ./docker-compose-e2e.yml up See chainbridge-solidity and chainbridge-substrate-chain for more information on testing facilities. All Go tests can be run with: $ make test Go tests specifically for ethereum, substrate and E2E can be run with $ make test-eth $ make test-sub $ make test-e2e The bindings for the solidity contracts live in bindings/ . To update the bindings modify scripts/setup-contracts.sh and then run make clean && make setup-contracts","title":"Testing"},{"location":"test/#testing","text":"Unit tests require an ethereum node running on localhost:8545 and a substrate node running on localhost:9944 . E2E tests require an additional ethereum node on localhost:8546 . A docker-compose file is provided to run two Geth nodes and a chainbridge-substrate-chain node in isolated environments: $ docker-compose -f ./docker-compose-e2e.yml up See chainbridge-solidity and chainbridge-substrate-chain for more information on testing facilities. All Go tests can be run with: $ make test Go tests specifically for ethereum, substrate and E2E can be run with $ make test-eth $ make test-sub $ make test-e2e The bindings for the solidity contracts live in bindings/ . To update the bindings modify scripts/setup-contracts.sh and then run make clean && make setup-contracts","title":"Testing"},{"location":"chains/eth-contracts/","text":"Ethereum Contracts \u00b6 Bridge Contract \u00b6 Users and relayers will interact with the Bridge contract. This delegates calls to the handler contracts for deposits and executing proposals. function deposit ( uint8 destinationChainID, bytes32 resourceID, bytes calldata data ) Handler Contracts \u00b6 To provide modularity and break out the necessary contract logic, the implementation uses a notion of handlers. A handler is defined for ERC20, ERC721 and generic transfers. These map directly to the Fungible, Non-Fungible, and generic transfer types. A handler must fulfill two interfaces: // Will be called by the bridge contract to initiate a transfer function deposit(uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) // TODO: This would be more aptly named executeProposal // Called by the bridge contract to complete a transfer function executeDeposit(bytes calldata data) The calldata field is the parameters required for the handler. The exact serialization is defined for each handler. ERC20 & ERC721 Handlers \u00b6 These handlers share a lot of similarities. These handlers are responsible for transferring ERC assets. They should provide the ability for the bridge to take ownership of tokens and release tokens to execute transfers. Different configurations may require different interface interactions. For example, it may make sense to mint and burn a token that is originally from another chain. If supply needs to be controlled, transferring tokens in and out of a reserve may be desired instead. To support either case handlers should associate each resource ID/token contract with one of these: transferFrom() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call transferFrom() as part of the transfer initiation. For the inverse, the handler will call transfer() to release tokens from the handlers ownership. mint() / burn() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call burnFrom() as part of the transfer initiation. For the inverse, the handler will call mint() to release tokens to the recipient (and must have privileges to do so). ERC20 Handler \u00b6 Calldata for deposit() \u00b6 Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END Calldata for executeDeposit() \u00b6 Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - END ERC721 Handler \u00b6 Metadata \u00b6 The tokenURI should be used as the metadata field if the contract supports the Metadata extension (interface ID 0x5b5e139f ). Calldata for deposit() \u00b6 Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END Calldata for executeDeposit() \u00b6 Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - 95 Metadata Length uint256 96 - 127 Metadata bytes 128 - END Generic Handler \u00b6 As well as associating a resource ID to a contract address, the generic handler should allow specific functions on those contracts to be used. To allow for this we must: Use function selectors to identify functions. Require functions that accept bytes as a the only parameter OR require the data already be ABI encoded for the function Deposit \u00b6 In a generic context, a deposit is simply the initiation of a transfer of a piece of data. To (optionally) allow this data to be validated for transfer the deposit mechanism should pass the data to a specified function and proceed with the transfer if the call succeeds (ie. does not revert). A function selector of 0x00 should skip the deposit function call. Execute \u00b6 An execution function must be specified. When executeDeposit() is called on the handler it should pass the metadata field to the specified function. Calldata for deposit() \u00b6 Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END Calldata for execute() \u00b6 Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END Administration \u00b6 The contracts should be controlled by an admin account. This should control the relayer set, manage the resource IDs, and specify the handlers. It should also be able to pause and unpause transfers at any times.","title":"Contracts"},{"location":"chains/eth-contracts/#ethereum-contracts","text":"","title":"Ethereum Contracts"},{"location":"chains/eth-contracts/#bridge-contract","text":"Users and relayers will interact with the Bridge contract. This delegates calls to the handler contracts for deposits and executing proposals. function deposit ( uint8 destinationChainID, bytes32 resourceID, bytes calldata data )","title":"Bridge Contract"},{"location":"chains/eth-contracts/#handler-contracts","text":"To provide modularity and break out the necessary contract logic, the implementation uses a notion of handlers. A handler is defined for ERC20, ERC721 and generic transfers. These map directly to the Fungible, Non-Fungible, and generic transfer types. A handler must fulfill two interfaces: // Will be called by the bridge contract to initiate a transfer function deposit(uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) // TODO: This would be more aptly named executeProposal // Called by the bridge contract to complete a transfer function executeDeposit(bytes calldata data) The calldata field is the parameters required for the handler. The exact serialization is defined for each handler.","title":"Handler Contracts"},{"location":"chains/eth-contracts/#erc20-erc721-handlers","text":"These handlers share a lot of similarities. These handlers are responsible for transferring ERC assets. They should provide the ability for the bridge to take ownership of tokens and release tokens to execute transfers. Different configurations may require different interface interactions. For example, it may make sense to mint and burn a token that is originally from another chain. If supply needs to be controlled, transferring tokens in and out of a reserve may be desired instead. To support either case handlers should associate each resource ID/token contract with one of these: transferFrom() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call transferFrom() as part of the transfer initiation. For the inverse, the handler will call transfer() to release tokens from the handlers ownership. mint() / burn() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call burnFrom() as part of the transfer initiation. For the inverse, the handler will call mint() to release tokens to the recipient (and must have privileges to do so).","title":"ERC20 &amp; ERC721 Handlers"},{"location":"chains/eth-contracts/#erc20-handler","text":"","title":"ERC20 Handler"},{"location":"chains/eth-contracts/#calldata-for-deposit","text":"Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END","title":"Calldata for deposit()"},{"location":"chains/eth-contracts/#calldata-for-executedeposit","text":"Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - END","title":"Calldata for executeDeposit()"},{"location":"chains/eth-contracts/#erc721-handler","text":"","title":"ERC721 Handler"},{"location":"chains/eth-contracts/#metadata","text":"The tokenURI should be used as the metadata field if the contract supports the Metadata extension (interface ID 0x5b5e139f ).","title":"Metadata"},{"location":"chains/eth-contracts/#calldata-for-deposit_1","text":"Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END","title":"Calldata for deposit()"},{"location":"chains/eth-contracts/#calldata-for-executedeposit_1","text":"Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - 95 Metadata Length uint256 96 - 127 Metadata bytes 128 - END","title":"Calldata for executeDeposit()"},{"location":"chains/eth-contracts/#generic-handler","text":"As well as associating a resource ID to a contract address, the generic handler should allow specific functions on those contracts to be used. To allow for this we must: Use function selectors to identify functions. Require functions that accept bytes as a the only parameter OR require the data already be ABI encoded for the function","title":"Generic Handler"},{"location":"chains/eth-contracts/#deposit","text":"In a generic context, a deposit is simply the initiation of a transfer of a piece of data. To (optionally) allow this data to be validated for transfer the deposit mechanism should pass the data to a specified function and proceed with the transfer if the call succeeds (ie. does not revert). A function selector of 0x00 should skip the deposit function call.","title":"Deposit"},{"location":"chains/eth-contracts/#execute","text":"An execution function must be specified. When executeDeposit() is called on the handler it should pass the metadata field to the specified function.","title":"Execute"},{"location":"chains/eth-contracts/#calldata-for-deposit_2","text":"Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END","title":"Calldata for deposit()"},{"location":"chains/eth-contracts/#calldata-for-execute","text":"Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END","title":"Calldata for execute()"},{"location":"chains/eth-contracts/#administration","text":"The contracts should be controlled by an admin account. This should control the relayer set, manage the resource IDs, and specify the handlers. It should also be able to pause and unpause transfers at any times.","title":"Administration"},{"location":"chains/ethereum/","text":"Ethereum Implementation Specification \u00b6 The solidity implementation of ChainBridge should consist of a central Bridge contract, and will delegate specific functionality to handlers . Fungible and non-fungible compatibility should be focused on ERC20 and ERC721 tokens. Transfer Flow \u00b6 As Source Chain \u00b6 Some user calls the deposit function on the bridge contract. A depositRecord is created on the bridge and a call is delgated to a handler contract specified by the provided resourceID . The specified handler's deposit function validates the parameters provided by the user. If successful, a depositRecord is created on the handler. If the call delegated to the handler is succesful, the bridge emits a Deposit event. Relayers parse the Deposit event and retrieve the associated DepositRecord from the handler to construct a message. As Destination Chain \u00b6 A Relayer calls voteProposal on the bridge contract. If a proposal corresponding with the parameters passed in does not exist, it is created and the Relayer's vote is recorded. If the proposal already exists, the Relayer's vote is simply recorded. Once we have met some vote threshold for a proposal , the bridge emits a ProposalFinalized event. Upon seeing a ProposalFinalized event, Relayers call the executeDeposit function on the bridge. executeDeposit delegates a call to a handler contract specified by the associated resourceID . The specified handler's executeDeposit function validates the parameters provided and makes a call to some contract to complete the transfer.","title":"Bridge Setup"},{"location":"chains/ethereum/#ethereum-implementation-specification","text":"The solidity implementation of ChainBridge should consist of a central Bridge contract, and will delegate specific functionality to handlers . Fungible and non-fungible compatibility should be focused on ERC20 and ERC721 tokens.","title":"Ethereum Implementation Specification"},{"location":"chains/ethereum/#transfer-flow","text":"","title":"Transfer Flow"},{"location":"chains/ethereum/#as-source-chain","text":"Some user calls the deposit function on the bridge contract. A depositRecord is created on the bridge and a call is delgated to a handler contract specified by the provided resourceID . The specified handler's deposit function validates the parameters provided by the user. If successful, a depositRecord is created on the handler. If the call delegated to the handler is succesful, the bridge emits a Deposit event. Relayers parse the Deposit event and retrieve the associated DepositRecord from the handler to construct a message.","title":"As Source Chain"},{"location":"chains/ethereum/#as-destination-chain","text":"A Relayer calls voteProposal on the bridge contract. If a proposal corresponding with the parameters passed in does not exist, it is created and the Relayer's vote is recorded. If the proposal already exists, the Relayer's vote is simply recorded. Once we have met some vote threshold for a proposal , the bridge emits a ProposalFinalized event. Upon seeing a ProposalFinalized event, Relayers call the executeDeposit function on the bridge. executeDeposit delegates a call to a handler contract specified by the associated resourceID . The specified handler's executeDeposit function validates the parameters provided and makes a call to some contract to complete the transfer.","title":"As Destination Chain"},{"location":"chains/substrate/","text":"Substrate Implementation Specification \u00b6 The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a Proposal type equivalent to a dispatchable call to theoretically allow for any call to be made. pub trait Trait : system :: Trait { type Proposal : Parameter + Dispatchable < Origin = Self :: Origin > + EncodeLike + GetDispatchInfo ; } Events \u00b6 To easily distinguish different transfer types we should define three event types: /// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata) FungibleTransfer ( ChainId , DepositNonce , ResourceId , U256 , Vec < u8 > ) /// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata) NonFungibleTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > , Vec < u8 > , Vec < u8 > ) /// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata) GenericTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > ) These can be observed by relayers and should provide enough context to construct transfer messages. Inter-Pallet Communication \u00b6 The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers: pub fn transfer_fungible ( dest_id : ChainId , resource_id : ResourceId , to : Vec < u8 > , amount : U256 ,) pub fn transfer_nonfungible ( dest_id : ChainId , resource_id : ResourceId , token_id : Vec < u8 > , to : Vec < u8 > , metadata : Vec < u8 > ) pub fn transfer_generic ( dest_id : ChainId , resource_id : ResourceId , metadata : Vec < u8 > ) These should result in the associated event being emitted with the correct parameters. Bridge Account ID & Origin Check \u00b6 To allow the bridge pallet to take ownership of tokens a ModuleId should be used to derive an AccountId . A bridge origin check (implementing EnsureOrigin ) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal. Executing Calls \u00b6 The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin. Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls: - Fungible: Call(origin, recipient: AccountId, amount: u128) - Non-Fungible: Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec<u8>) - Generic: Call(origin, data: Vec<u8>) Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls","title":"Substrate"},{"location":"chains/substrate/#substrate-implementation-specification","text":"The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a Proposal type equivalent to a dispatchable call to theoretically allow for any call to be made. pub trait Trait : system :: Trait { type Proposal : Parameter + Dispatchable < Origin = Self :: Origin > + EncodeLike + GetDispatchInfo ; }","title":"Substrate Implementation Specification"},{"location":"chains/substrate/#events","text":"To easily distinguish different transfer types we should define three event types: /// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata) FungibleTransfer ( ChainId , DepositNonce , ResourceId , U256 , Vec < u8 > ) /// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata) NonFungibleTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > , Vec < u8 > , Vec < u8 > ) /// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata) GenericTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > ) These can be observed by relayers and should provide enough context to construct transfer messages.","title":"Events"},{"location":"chains/substrate/#inter-pallet-communication","text":"The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers: pub fn transfer_fungible ( dest_id : ChainId , resource_id : ResourceId , to : Vec < u8 > , amount : U256 ,) pub fn transfer_nonfungible ( dest_id : ChainId , resource_id : ResourceId , token_id : Vec < u8 > , to : Vec < u8 > , metadata : Vec < u8 > ) pub fn transfer_generic ( dest_id : ChainId , resource_id : ResourceId , metadata : Vec < u8 > ) These should result in the associated event being emitted with the correct parameters.","title":"Inter-Pallet Communication"},{"location":"chains/substrate/#bridge-account-id-origin-check","text":"To allow the bridge pallet to take ownership of tokens a ModuleId should be used to derive an AccountId . A bridge origin check (implementing EnsureOrigin ) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal.","title":"Bridge Account ID &amp; Origin Check"},{"location":"chains/substrate/#executing-calls","text":"The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin. Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls: - Fungible: Call(origin, recipient: AccountId, amount: u128) - Non-Fungible: Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec<u8>) - Generic: Call(origin, data: Vec<u8>) Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls","title":"Executing Calls"}]}