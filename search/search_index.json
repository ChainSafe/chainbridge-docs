{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udf09  Overview","text":""},{"location":"#summary","title":"Summary","text":"<p>ChainBridge is an extensible cross-chain communication protocol. It currently supports bridging between EVM and Substrate based chains.</p> <p>A bridge contract (or pallet in Substrate) on each chain forms either side of a bridge. Handler contracts allow for customizable behavior upon receiving transactions to and from the bridge. For example locking up an asset on one side and minting a new one on the other. Its highly customizable - you can deploy a handler contract to perform any action you like.</p> <p>In its current state ChainBridge operates under a trusted federation model. Deposit events on one chain are detected by a trusted set of off-chain relayers who await finality, submit events to the other chain and vote on submissions to reach acceptance triggering the appropriate handler.</p> <p>Research is currently underway to reduce the levels of trust required and move toward a fully trust-less bridge.</p> <p></p>"},{"location":"#relevant-repos","title":"Relevant repos","text":""},{"location":"#chainbridge","title":"ChainBridge","text":"<p>This is the core bridging software that Relayers run between chains.</p>"},{"location":"#chainbridge-solidity","title":"chainbridge-solidity","text":"<p>The Solidity contracts required for chainbridge. Includes deployment and interaction CLI.</p>"},{"location":"#chainbridge-substrate","title":"chainbridge-substrate","text":"<p>A substrate pallet that can be integrated into a chain, as well as an example pallet to demonstrate chain integration.</p>"},{"location":"#chainbridge-utils","title":"chainbridge-utils","text":"<p>A collection of packages used by the core bridging software.</p>"},{"location":"#chainbridge-deploy","title":"chainbridge-deploy","text":"<p>Some tooling to help with deployments.</p>"},{"location":"cli-options/","title":"CLI Options","text":""},{"location":"cli-options/#flags","title":"Flags","text":""},{"location":"cli-options/#global","title":"Global","text":"<pre><code>--config value       JSON configuration file\n--verbosity value    Supports levels crit (silent) to trce (trace) (default: \"info\")\n--keystore value     Path to keystore directory (default: \"./keys\")\n--blockstore value   Specify path for blockstore\n--fresh              Disables loading from blockstore at start. Opts will still be used if specified. (default: false)\n--latest             Overrides blockstore and start block, starts from latest block (default: false)\n--metrics            Enables metric server (default: false)\n--metricsPort value  Port to serve metrics on (default: 8001)\n--testkey value      Applies a predetermined test keystore to the chains.\n--help, -h           show help (default: false)\n--version, -v        print the version (default: false)\n</code></pre>"},{"location":"cli-options/#account-management","title":"Account Management","text":"<p>The commands can be used to manage keys in the local keystore. You can view available keys with <code>chainbridge accounts list</code>.</p>"},{"location":"cli-options/#chainbridge-accounts-generate","title":"<code>chainbridge accounts generate</code>","text":"<pre><code>--password value  Password used to encrypt the keystore. Used with --generate, --import, or --unlock\n--sr25519         Specify account/key type as sr25519. (default: false)\n--secp256k1       Specify account/key type as secp256k1. (default: false)\n--network value   Specify the network to use for the address encoding (substrate/polkadot/centrifuge) (default: substrate)\n</code></pre>"},{"location":"cli-options/#chainbridge-accounts-import","title":"<code>chainbridge accounts import</code>","text":"<pre><code>--ethereum          Import an existing ethereum keystore, such as from geth. (default: false)\n--privateKey value  Import a hex representation of a private key into a keystore.\n--sr25519           Specify account/key type as sr25519. (default: false)\n--secp256k1         Specify account/key type as secp256k1. (default: false)\n--password value    Password used to encrypt the keystore. Used with --generate, --import, or --unlock\n--network value     Specify the network to use for the address encoding (substrate/polkadot/centrifuge) (default: substrate)\n</code></pre>"},{"location":"cli-options/#environment-variables","title":"Environment Variables","text":"<ul> <li><code>KEYSTORE_PASSWORD</code>: The password to use when loading the keystore.</li> <li><code>BLOCK_TIMEOUT</code>: The duration (seconds) until a chain is considered \"unhealthy\"</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>Note: TOML configs have been deprecated in favour of JSON</p> <p>A chain configurations take this form:</p> <pre><code>{\n\"name\": \"eth\",                      // Human-readable name\n\"type\": \"ethereum\",                 // Chain type (eg. \"ethereum\" or \"substrate\")\n\"id\": \"0\",                          // Chain ID\n\"endpoint\": \"ws://&lt;host&gt;:&lt;port&gt;\",   // Node endpoint\n\"from\": \"0xff93...\",                // On-chain address of relayer\n\"opts\": {},                         // Chain-specific configuration options (see below)\n}\n</code></pre> <p>See <code>config.json.example</code> for an example configuration. </p>"},{"location":"configuration/#ethereum-options","title":"Ethereum Options","text":"<p>Ethereum chains support the following additional options:</p> <pre><code>{\n    \"bridge\": \"0x12345...\",          // Address of the bridge contract (required)\n\"erc20Handler\": \"0x1234...\",     // Address of erc20 handler\n\"erc721Handler\": \"0x1234...\",    // Address of erc721 handler\n\"genericHandler\": \"0x1234...\",   // Address of generic handler\n\"maxGasPrice\": \"0x1234\",         // Gas price for transactions (default: 20000000000)\n\"gasLimit\": \"0x1234\",            // Gas limit for transactions (default: 6721975)\n\"gasMultiplier\": \"1.25\",         // Multiplies the gas price by the supplied value (default: 1)\n\"http\": \"true\",                  // Whether the chain connection is ws or http (default: false)\n\"startBlock\": \"1234\",            // The block to start processing events from (default: 0)\n\"blockConfirmations\": \"10\"       // Number of blocks to wait before processing a block\n\"egsApiKey\": \"xxx...\"            // API key for Eth Gas Station (https://www.ethgasstation.info/)\n\"egsSpeed\": \"fast\"               // Desired speed for gas price selection, the options are: \"average\", \"fast\", \"fastest\"\n}\n</code></pre>"},{"location":"configuration/#substrate-options","title":"Substrate Options","text":"<p>Substrate supports the following additonal options:</p> <pre><code>{\n    \"startBlock\": \"1234\" // The block to start processing events from (default: 0)\n\"useExtendedCall\": \"true\" // Extend extrinsic calls to substrate with ResourceID. Used for backward compatibility with example pallet.\n}\n</code></pre>"},{"location":"configuration/#blockstore","title":"Blockstore","text":"<p>The blockstore is used to record the last block the relayer processed, so it can pick up where it left off. </p> <p>If a <code>startBlock</code> option is provided (see Configuration), then the greater of <code>startBlock</code> and the latest block in the blockstore is used at startup.</p> <p>To disable loading from the blockstore specify the <code>--fresh</code> flag. A custom path for the blockstore can be provided with <code>--blockstore &lt;path&gt;</code>. For development, the <code>--latest</code> flag can be used to start from the current block and override any other configuration.</p>"},{"location":"configuration/#keystore","title":"Keystore","text":"<p>ChainBridge requires keys to sign and submit transactions, and to identify each bridge node on chain.</p> <p>To use secure keys, see <code>chainbridge accounts --help</code>. The keystore password can be supplied with the <code>KEYSTORE_PASSWORD</code> environment variable.</p> <p>To import external ethereum keys, such as those generated with geth, use <code>chainbridge accounts import --ethereum /path/to/key</code>.</p> <p>To import private keys as keystores, use <code>chainbridge accounts import --privateKey key</code>.</p> <p>For testing purposes, chainbridge provides 5 test keys. The can be used with <code>--testkey &lt;name&gt;</code>, where <code>name</code> is one of <code>Alice</code>, <code>Bob</code>, <code>Charlie</code>, <code>Dave</code>, or <code>Eve</code>. </p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#where-can-i-find-help-if-i-have-further-questions","title":"Where can I find help if I have further questions?","text":"<p>You can join our Discord server. In case you have issues with bridge, feel free to create issue in github.</p>"},{"location":"faq/#can-you-build-an-implementation-for-my-project","title":"Can you build an implementation for my project?","text":"<p>We don't currently have capacity to build implementations of ChainBridge. However, you can jump into the relevant channel on our Discord to find other teams who want to work on the same implementation as you.</p>"},{"location":"faq/#can-you-run-a-relayer-for-my-project","title":"Can you run a relayer for my project?","text":"<p>Our focus right now is on building software to enable other teams to run bridges. At this time we are not looking to run relayers for any projects or bridge implementations.</p>"},{"location":"faq/#i-need-support-to-useintegrate-with-a-specific-chainbridge-implementation","title":"I need support to use/integrate with a specific ChainBridge implementation.","text":"<p>While we are the developers of ChainBridge, we are not formally affiliated with any projects or bridge implementations. Please reach out to the relevant team/project for implementation-specific support.</p> <p>Avalanche: https://t.me/aebtechnicalsupport</p> <p>Expanse: https://discord.gg/DUN6r2X</p>"},{"location":"faq/#i-want-to-try-out-chainbridge-locally-how-can-i-do-that","title":"I want to try out ChainBridge locally, how can I do that?","text":"<p>You can follow these instructions to run an Ethereum &lt;&gt; Substrate bridge locally https://chainbridge.chainsafe.io/local/</p>"},{"location":"faq/#im-having-issues-running-chainbridge-with-ganache","title":"I'm having issues running ChainBridge with Ganache","text":"<p>ChainBridge is not compatible with Ganache. Please try running Geth or any real node instead.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#dependencies","title":"Dependencies","text":"<ul> <li>Subkey:  Used for substrate key management. Only required if connecting to a substrate chain.</li> </ul> <pre><code>make install-subkey\n</code></pre>"},{"location":"installation/#building-from-source","title":"Building from Source","text":"<p>To build <code>chainbridge</code> in <code>./build</code>.</p> <pre><code>make build\n</code></pre> <p>or</p> <p>Use<code>go install</code> to add <code>chainbridge</code> to your GOBIN.</p> <pre><code>make install\n</code></pre>"},{"location":"installation/#docker","title":"Docker","text":"<p>The official ChainBridge Docker image can be found here.</p> <p>To build the Docker image locally run: </p> <pre><code>docker build -t chainsafe/chainbridge .\n</code></pre> <p>To start ChainBridge:</p> <pre><code>docker run -v $(pwd)/config.json:/config.json chainsafe/chainbridge\n</code></pre>"},{"location":"live-evm-bridge/","title":"Deploying a Live EVM-&gt;EVM Token Bridge","text":"<p>This tutorial walks through the process of deploying a token exchange bridge between two Ethereum test networks (G\u00f6rli and Rinkeby). It could similarly be applied to link any two EVM-based chains including the Ethereum mainnet.</p> <p>At a high level setting up ChainBridge for token transfers requires the following:</p> <ul> <li>A token native to ChainA (e.g. TKN) and a destination token on ChainB which will represent the source token wrapped (e.g. wTKN)</li> <li>The ChainBridge bridge contract deployed to each chain</li> <li>Handler contracts on each chain to instruct the bridge what to do with the tokens</li> <li>One or more off-chain relayers running to pick up transactions from the source chain and relay them to the destination chain</li> </ul>"},{"location":"live-evm-bridge/#overview-of-cross-chain-token-transfers","title":"Overview of Cross-chain Token Transfers","text":"<p>Tokens are inherently native to a single chain; however, with a bit of contract magic it is possible to make something equivalent to transferring value between two chains.</p>"},{"location":"live-evm-bridge/#lock-and-mint-burn-and-release","title":"Lock-and-Mint | Burn-and-Release","text":"<p>This approach is appealing because it imposes very few requirements on the asset on the source chain other than it must be transferable and lockable in a contract. This makes it possible to use with native assets (e.g. ETH) or existing tokens that you don't control.</p> <p>The basic flow of lock-and-mint is as follows:</p> <ol> <li>Assets on the source chain are deposited in a bridge contract which locks them up</li> <li>A relayer observes this transaction and sends a new transaction to the bridge contract on the destination chain. This transaction should include a proof of the deposit on the source chain and a destination which is owned by the depositor</li> <li>The bridge contract mints new tokens on the destination chain into the depositors account on this chain</li> </ol> <p>It is important to notice that the total number of liquid (non-locked) tokens on both chains combined remains the same. Exchanging the tokens on the destination chain back to native tokens uses the inverse operation, burn-and-release.</p> <ol> <li>Tokens on the destination chain are sent to a bridge contract which burns them</li> <li>A relayer observes this transaction and sends a new transaction to the bridge contract on the source chain. This transaction should include a proof of the burn and a destination address</li> <li>The bridge contract unlocks some number of tokens and deposits them into the destination account</li> </ol> <p>Provided this refunding of tokens can be executed at any time and the number of locked tokens is always equal to the number of minted wrapped tokens, then we can say that the wrapped tokens have value equal to the original asset.</p>"},{"location":"live-evm-bridge/#chainbridge-components","title":"ChainBridge Components","text":"<p>A ChainBridge deployment on EVM-based chains requires the following components:</p>"},{"location":"live-evm-bridge/#bridge-contract","title":"Bridge Contract","text":"<p>The bridge contract must be deployed on both the source and destination chains. Its primary task on the source chain is to broker token deposits (ensure they are locked) and emit the events that the relayers listen for. On the destination chain, the bridge contract is responsible for managing a set of permissioned relayers, aggregating relayer votes on proposals passed from the source chain, and executing the desired action (e.g. minting tokens) on the destination chain when the vote threshold is reached.</p>"},{"location":"live-evm-bridge/#handlers","title":"Handlers","text":"<p>To allow extensibility the bridge contract is written to call functions in a handler contract when tokens are deposited on the source chain or when a proposal is approved on the destination chain. Each resource (e.g. token) can have a unique handler. You are free to write your own handler contract that implements any functionality you like. </p> <p>The ERC20 handler contract that ships with ChainBridge can be configured to either lock up the tokens or burn them (if the token allows) on deposit and either mint or release tokens when a proposal is executed. A single handler can handle many tokens but their contract addresses must be registered with the handler ahead of time.</p>"},{"location":"live-evm-bridge/#relayers","title":"Relayers","text":"<p>The relayer is an off-chain actor that listens for particular events on the source chain and- when certain conditions are met- will submit signed proposals to the destination chain. The addresses of the approved relayers must be registered with the bridge contract on the destination chain.</p> <p>Once a proposal has sufficient votes a relayer can execute the proposal to trigger the handler.</p>"},{"location":"live-evm-bridge/#deploying-your-own-bridge","title":"Deploying your own bridge","text":""},{"location":"live-evm-bridge/#preparation","title":"Preparation","text":""},{"location":"live-evm-bridge/#accounts","title":"Accounts","text":"<p>If you want to follow along with this guide we will be deploying a bridge between two Ethereum test networks (G\u00f6rli and Rinkeby). </p> <p>You will need one account on each network from which to deploy the contracts. These can be easily created using MetaMask. Be careful to use test accounts only as some of the commands in this tutorial require access to your private key.</p> <p>This will cost gas so some test ETH will be required. So first up grab some test ether from the faucets:</p> <ul> <li>https://goerli-faucet.slock.it/</li> <li>https://faucet.rinkeby.io/</li> </ul> <p>You will need around 0.1 each of Goerli ETH and Rinkeby ETH.</p> <p>We will be creating a bridge that wraps the test ERC20 token WEENUS on G\u00f6rli as a wrapped version (wWEENUS) on Rinkeby. So also grab some free WEENUS tokens by sending a 0 ETH transaction to the contract address on G\u00f6rli: 0xaFF4481D10270F50f203E0763e2597776068CBc5</p>"},{"location":"live-evm-bridge/#tooling","title":"Tooling","text":"<p>We will be using the ChainBridge contract CLI to deploy and interact with the contracts. Grab and install the CLI by running: </p> <pre><code>git clone -b v1.0.0 --depth 1 https://github.com/ChainSafe/chainbridge-deploy \\\n&amp;&amp; cd chainbridge-deploy/cb-sol-cli \\\n&amp;&amp; npm install \\\n&amp;&amp; make install\n</code></pre> <p>This will also download and build the required Solidity contracts.</p> <p>To avoid duplication in the subsequent commands set the following env vars in your shell:</p> <pre><code>SRC_GATEWAY=https://goerli-light.eth.linkpool.io/\nDST_GATEWAY=https://rinkeby-light.eth.linkpool.io/\n\nSRC_ADDR=\"&lt;Your address on G\u00f6rli&gt;\"\nSRC_PK=\"&lt;your private key on G\u00f6rli&gt;\"\nDST_ADDR=\"&lt;Your address on Rinkeby&gt;\"\nDST_PK=\"&lt;your private key on Rinkeby&gt;\"\n\nSRC_TOKEN=\"0xaFF4481D10270F50f203E0763e2597776068CBc5\"\nRESOURCE_ID=\"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\"\n</code></pre> <p>You could also write the above to a file (e.g. <code>chainbridge-vars</code>) and load it into your shell by running <code>set -a; source ./chainbridge-vars; set +a</code>.</p> <p>You can use MetaMask to generate new accounts on the test networks and export your public and private keys.</p> <p>Additional env vars are required to be set throughout the tutorial. If a command doesn't work be sure you have set the required variables.</p>"},{"location":"live-evm-bridge/#steps","title":"Steps","text":""},{"location":"live-evm-bridge/#1-deploy-contracts-on-source-gorli","title":"1. Deploy contracts on Source (G\u00f6rli)","text":"<p>The following command will deploy the bridge contract and ERC20 handler contract on the source.</p> <pre><code>cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 deploy \\\n--bridge --erc20Handler \\\n--relayers $SRC_ADDR \\\n--relayerThreshold 1\\\n--chainId 0\n</code></pre> <p>Take note of the output of the above command and assign the following variables.</p> <pre><code>SRC_BRIDGE=\"&lt;resulting bridge contract address&gt;\"\nSRC_HANDLER=\"&lt;resulting erc20 handler contract address&gt;\"\n</code></pre>"},{"location":"live-evm-bridge/#2-configure-contracts-on-source","title":"2. Configure contracts on Source","text":"<p>The following registers the WEENUS token as a resource with a bridge contract and configures which handler to use.</p> <pre><code>cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 bridge register-resource \\\n--bridge $SRC_BRIDGE \\\n--handler $SRC_HANDLER \\\n--resourceId $RESOURCE_ID \\\n--targetContract $SRC_TOKEN\n</code></pre> <p>Note: Sometimes the transaction confirmation will not be detected by the CLI. You can check the txhash in etherscan to see if it has been confirmed.</p>"},{"location":"live-evm-bridge/#3-deploy-contracts-on-destination-rinkeby","title":"3. Deploy contracts on Destination (Rinkeby)","text":"<p>The following command deploys the bridge contract, handler and a new ERC20 contract (wWEENUS) on the destination chain. It also configures your account as a verified relayer.</p> <pre><code>cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 deploy\\\n--bridge --erc20 --erc20Handler \\\n--relayers $DST_ADDR \\\n--relayerThreshold 1 \\\n--chainId 1\n</code></pre> <p>Again, assign the following env variables.</p> <pre><code>DST_BRIDGE=\"&lt;resulting bridge contract address&gt;\"\nDST_HANDLER=\"&lt;resulting erc20 handler contract address&gt;\"\nDST_TOKEN=\"&lt;resulting erc20 token address&gt;\"\n</code></pre>"},{"location":"live-evm-bridge/#4-configure-contracts-on-destination","title":"4. Configure contracts on Destination","text":"<p>The following registers the new token (wWEENUS) as a resource on the bridge similar to the above.</p> <pre><code>cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 bridge register-resource \\\n--bridge $DST_BRIDGE \\\n--handler $DST_HANDLER \\\n--resourceId $RESOURCE_ID \\\n--targetContract $DST_TOKEN\n</code></pre> <p>The following registers the token as mintable/burnable on the bridge.</p> <pre><code>cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 bridge set-burn \\\n--bridge $DST_BRIDGE \\\n--handler $DST_HANDLER \\\n--tokenContract $DST_TOKEN\n</code></pre> <p>The following gives permission for the handler to mint new wWEENUS tokens.</p> <pre><code>cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 erc20 add-minter \\\n--minter $DST_HANDLER \\\n--erc20Address $DST_TOKEN\n</code></pre>"},{"location":"live-evm-bridge/#create-a-relayer","title":"Create a Relayer","text":"<p>With the above complete, the Ethereum side of the setup is finished. The only missing piece is a relayer to detect events on the source chain and submit them as proposals on the destination chain.</p> <p>In configuring the destination bridge contract we set the relayer threshold to 1, meaning only a single relayer must vote on a proposal for it to be approved. This is OK for testing but in practice a much larger set of relayers should be used with a suitable high threshold to make collusion difficult.</p>"},{"location":"live-evm-bridge/#1-build-the-relayer","title":"1. Build the relayer","text":"<pre><code>git clone -b v1.1.1 --depth 1 https://github.com/ChainSafe/chainbridge \\\n&amp;&amp; cd chainbridge \\\n&amp;&amp; make build\n</code></pre>"},{"location":"live-evm-bridge/#2-author-a-config","title":"2. Author a config","text":"<p>Execute the command below to create a config file with all the variables assigned in previous steps.</p> <pre><code>echo \"{\n  \\\"chains\\\": [\n    {\n      \\\"name\\\": \\\"Goerli\\\",\n      \\\"type\\\": \\\"ethereum\\\",\n      \\\"id\\\": \\\"0\\\",\n      \\\"endpoint\\\": \\\"wss://goerli-light.eth.linkpool.io/ws\\\",\n      \\\"from\\\": \\\"$SRC_ADDR\\\",\n      \\\"opts\\\": {\n        \\\"bridge\\\": \\\"$SRC_BRIDGE\\\",\n        \\\"erc20Handler\\\": \\\"$SRC_HANDLER\\\",\n        \\\"genericHandler\\\": \\\"$SRC_HANDLER\\\",\n        \\\"gasLimit\\\": \\\"1000000\\\",\n        \\\"maxGasPrice\\\": \\\"10000000000\\\"\n      }\n    },\n    {\n      \\\"name\\\": \\\"Rinkeby\\\",\n      \\\"type\\\": \\\"ethereum\\\",\n      \\\"id\\\": \\\"1\\\",\n      \\\"endpoint\\\": \\\"wss://rinkeby-light.eth.linkpool.io/ws\\\",\n      \\\"from\\\": \\\"$DST_ADDR\\\",\n      \\\"opts\\\": {\n        \\\"bridge\\\": \\\"$DST_BRIDGE\\\",\n        \\\"erc20Handler\\\": \\\"$DST_HANDLER\\\",\n        \\\"genericHandler\\\": \\\"$DST_HANDLER\\\",\n        \\\"gasLimit\\\": \\\"1000000\\\",\n        \\\"maxGasPrice\\\": \\\"10000000000\\\"\n      }\n    }\n  ]\n}\" &gt;&gt; config.json\n</code></pre>"},{"location":"live-evm-bridge/#3-set-up-keys","title":"3. Set up keys","text":"<p>The relayer maintains its own keystore. To add a new account on the source and destination chains run:</p> <pre><code>./build/chainbridge accounts import --privateKey $SRC_PK\n</code></pre> <pre><code>./build/chainbridge accounts import --privateKey $DST_PK\n</code></pre> <p>Note: The second command might fail if you are using the same keys on both networks. That's OK just keep going</p>"},{"location":"live-evm-bridge/#lets-test-our-bridge","title":"Lets test our bridge!","text":"<p>First start the relayer by running:</p> <pre><code>./build/chainbridge --config config.json --verbosity trace --latest\n</code></pre> <p>The <code>latest</code> flag ensures that the relayer starts monitoring blocks from the most recent it can find and won't attempt to look through the history. Leave the relay running in a seperate shell while you run the commands below.</p> <p>Approve the handler to spend tokens on our behalf (to transfer them to the token safe).</p> <pre><code>cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 erc20 approve \\\n--amount 100 \\\n--erc20Address $SRC_TOKEN \\\n--recipient $SRC_HANDLER\n</code></pre> <p>Note: Most ERC20 contracts use 18 decimal places. The amount specified will be encoded with the necessary decimal places. This can be configured with <code>--decimals</code> on the <code>erc20</code> command.</p> <p>Execute a deposit.</p> <pre><code>cb-sol-cli --url $SRC_GATEWAY --privateKey $SRC_PK --gasPrice 10000000000 erc20 deposit \\\n--amount 100 \\\n--dest 1 \\\n--bridge $SRC_BRIDGE \\\n--recipient $DST_ADDR \\\n--resourceId $RESOURCE_ID\n</code></pre> <p>The relayer will wait 10 block confirmations before submitting a request which may take a few minutes on the test network. Keep an eye on the <code>target=XXXX</code> output in the chainbridge relayer window. The transfer will occur when this reaches the block height of the deposit transaction.</p> <p>The relayer will show something similar to the below when it picks up a transaction and relays it. </p> <p>Some time later it will execute the proposal on the destination chain.</p> <p></p> <p>When checking your balance for the token on the destination chain you should see the inbound tokens from the handler.</p> <p>Proposals will continue to be forwarded provided you keep the relayer process running.</p>"},{"location":"live-evm-bridge/#and-back-again","title":"And back again!","text":"<p>The bridge we've created already supports bi-directional transactions. We can submit a transaction to move tokens back from the destination to the source.</p> <p>Approve the handler on the destination chain to move tokens on our behalf (to burn them).</p> <pre><code>cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 erc20 approve \\\n--amount 1000000000000000000 \\\n--erc20Address $DST_TOKEN \\\n--recipient $DST_HANDLER\n</code></pre> <p>Transfer the wrapped tokens back to the bridge. This should result in the locked tokens being freed on the source chain and returned to your account.</p> <pre><code>cb-sol-cli --url $DST_GATEWAY --privateKey $DST_PK --gasPrice 10000000000 erc20 deposit \\\n--amount 1000000000000000000 \\\n--dest 0 \\\n--bridge $DST_BRIDGE \\\n--recipient $SRC_ADDR \\\n--resourceId $RESOURCE_ID\n</code></pre>"},{"location":"live-evm-bridge/#closing-thoughts","title":"Closing thoughts","text":"<p>It is also simple to extend the above to work with non-fungible assets (e.g. ERC721) by deploying another handler contract and reconfiguring the bridge.</p> <p>Of course having a single relayer is a highly centralised way to be running the bridge. With additional calls to <code>add-relayer</code> it is easy to set up extra accounts that can relay simultaneuosly. Once there are plenty of relayers you can increase the vote threshold so that a certain number of relayers need to agree on a proposal before it is executed.</p> <p>Read the documentation for the CLI tool to see how the bridge contract and handlers can be configured for different scenarios.</p>"},{"location":"local/","title":"Running Locally","text":""},{"location":"local/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker, docker-compose</li> <li>chainbridge <code>v1.1.1</code> binary (see README)</li> <li>cb-sol-cli (see README)</li> </ul>"},{"location":"local/#steps-to-get-started","title":"Steps To Get Started","text":"<ol> <li><code>Start Local Chains</code></li> <li><code>Connect to PolkadotJS Portal</code></li> <li><code>Deploy Contracts</code></li> <li><code>Register Resources Ethereum</code></li> <li><code>Specify Token Semantics</code></li> <li><code>Register Relayers</code></li> <li><code>Register Resources Substrate</code></li> <li><code>Whitelist Chains</code></li> <li><code>Run Relayer</code></li> <li><code>Fungible Transfers</code></li> <li><code>Non-Fungible Transfers</code></li> </ol>"},{"location":"local/#start-local-chains","title":"Start Local Chains","text":"<p>The easiest way to get started is to use the below docker-compose snippet. </p> <p>This will start one geth instance and an instance of chainbridge-substrate-chain:</p> <pre><code># Copyright 2020 ChainSafe Systems\n# SPDX-License-Identifier: LGPL-3.0-only\n\nversion: '3'\nservices:\ngeth1:\nimage: \"chainsafe/chainbridge-geth:20200505131100-5586a65\"\ncontainer_name: geth1\nports:\n- \"8545:8545\"\n\nsub-chain:\nimage: \"chainsafe/chainbridge-substrate-chain:v1.3.0\"\ncontainer_name: sub-chain\ncommand: chainbridge-substrate-chain --dev --alice --ws-external --rpc-external\nports:\n- \"9944:9944\"\n</code></pre> <p>Start Chains:</p> <pre><code>docker-compose -f docker-compose-snippet.yml up -V\n</code></pre> <p>(Use <code>-V</code> to always start with new chains. These instructions depend on deterministic Ethereum addresses, which are used as defaults implicitly by some of these commands. Avoid re-deploying the contracts without restarting both chains, or ensure to specify all the required parameters.)</p>"},{"location":"local/#connect-to-polkadotjs-portal","title":"Connect to PolkadotJS Portal","text":"<ol> <li>Access the PolkadotJS Portal for Centrifuge, as an example Substrate chain, here</li> <li>Connect to your local Substrate chain:<ul> <li>Click the network in the top-left corner</li> <li>Select the Development dropdown</li> <li>Set <code>ws://localhost:9944</code> as the custom endpoint</li> <li>Click <code>Switch</code> to connect</li> </ul> </li> <li>Set up type definitions for the chain:<ul> <li>Navigate to <code>Settings</code></li> <li>Select the <code>Developer</code> tab</li> <li>Paste in the below Type Defintions</li> <li>Save</li> </ul> </li> </ol> <p>Type Defintions:</p> <pre><code>{\n\"chainbridge::ChainId\": \"u8\",\n\"ChainId\": \"u8\",\n\"ResourceId\": \"[u8; 32]\",\n\"DepositNonce\": \"u64\",\n\"ProposalVotes\": {\n\"votes_for\": \"Vec&lt;AccountId&gt;\",\n\"votes_against\": \"Vec&lt;AccountId&gt;\",\n\"status\": \"enum\"\n},\n\"Erc721Token\": {\n\"id\": \"TokenId\",\n\"metadata\": \"Vec&lt;u8&gt;\"\n},\n\"TokenId\": \"U256\",\n\"Address\": \"AccountId\",\n\"LookupSource\": \"AccountId\"\n}\n</code></pre> <ul> <li>These can be found found here</li> </ul>"},{"location":"local/#on-chain-setup-ethereum","title":"On-Chain Setup (Ethereum)","text":""},{"location":"local/#deploy-contracts","title":"Deploy Contracts","text":"<p>To deploy the contracts on to the Ethereum chain, run the following:</p> <p>Deploy Contracts:</p> <pre><code>cb-sol-cli deploy --all --relayerThreshold 1\n</code></pre> <p>After running, the expected output looks like this:</p> <pre><code>================================================================\nUrl:        http://localhost:8545\nDeployer:   0xff93B45308FD417dF303D6515aB04D9e89a750Ca\nGas Limit:   8000000\nGas Price:   20000000\nDeploy Cost: 0.0\n\nOptions\n=======\nChain Id:    0\nThreshold:   1\nRelayers:    0xff93B45308FD417dF303D6515aB04D9e89a750Ca,0x8e0a907331554AF72563Bd8D43051C2E64Be5d35,0x24962717f8fA5BA3b931bACaF9ac03924EB475a0,0x148FfB2074A9e59eD58142822b3eB3fcBffb0cd7,0x4CEEf6139f00F9F4535Ad19640Ff7A0137708485\nBridge Fee:  0\nExpiry:      100\n\nContract Addresses\n================================================================\nBridge:             0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B\n----------------------------------------------------------------\nErc20 Handler:      0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\n----------------------------------------------------------------\nErc721 Handler:     0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\n----------------------------------------------------------------\nGeneric Handler:    0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\n----------------------------------------------------------------\nErc20:              0x21605f71845f372A9ed84253d2D024B7B10999f4\n----------------------------------------------------------------\nErc721:             0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\n----------------------------------------------------------------\nCentrifuge Asset:   Not Deployed\n----------------------------------------------------------------\nWETC:               Not Deployed\n================================================================\n</code></pre>"},{"location":"local/#register-resources-ethereum","title":"Register Resources Ethereum","text":"<ul> <li>NOTE: The below registrations will not notify you upon successful completion.</li> </ul> <p>Register fungile resource ID with erc20 contract:</p> <pre><code>cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\" --targetContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\"\n</code></pre> <p>Register non-fungible resource ID with erc721 contract:</p> <pre><code>cb-sol-cli bridge register-resource --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --targetContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\"\n</code></pre> <p>Register generic resource ID:</p> <pre><code>cb-sol-cli bridge register-generic-resource --resourceId \"0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01\" --targetContract \"0xc279648CE5cAa25B9bA753dAb0Dfef44A069BaF4\" --handler \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\" --hash --deposit \"\" --execute \"store(bytes32)\"\n</code></pre>"},{"location":"local/#specify-token-semantics","title":"Specify Token Semantics","text":"<p>To allow for a variety of use cases, the Ethereum contracts support both the <code>transfer</code> and the <code>mint/burn</code> ERC methods.</p> <p>For simplicity's sake the following examples only make use of the  <code>mint/burn</code> method:</p> <p>Register the erc20 contract as mintable/burnable:</p> <pre><code>cb-sol-cli bridge set-burn --tokenContract \"0x21605f71845f372A9ed84253d2D024B7B10999f4\"\n</code></pre> <p>Register the associated handler as a minter:</p> <pre><code>cb-sol-cli erc20 add-minter --minter \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\"\n</code></pre> <p>Register the erc721 contract as mintable/burnable:</p> <pre><code>cb-sol-cli bridge set-burn --tokenContract \"0xd7E33e1bbf65dC001A0Eb1552613106CD7e40C31\" --handler \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\"\n</code></pre> <p>Add the handler as a minter:</p> <pre><code>cb-sol-cli erc721 add-minter --minter \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\"\n</code></pre>"},{"location":"local/#on-chain-setup-substrate","title":"On-Chain Setup (Substrate)","text":""},{"location":"local/#register-relayers","title":"Register Relayers","text":"<p>First, we need to register the account of the relayer on Substrate (cb-sol-cli deploys contracts with the 5 test keys preloaded). </p> <p>Steps to register the relayers:</p> <ol> <li>Select the <code>Sudo</code> tab in the PolkadotJS Portal</li> <li>Choose the <code>addRelayer</code> method of <code>chainBridge</code></li> <li>Select Alice as the relayer <code>AccountId</code></li> </ol>"},{"location":"local/#register-resources-substrate","title":"Register Resources Substrate","text":"<p>Steps to register resources:</p> <ol> <li>Select the <code>Sudo</code> tab in the PolkadotJS Portal</li> <li>Call <code>chainBridge.setResource</code>, passing both the <code>Id</code> and <code>Method</code> listed below for each of the transfer types you wish to use</li> </ol> <p>Fungible (Native asset):</p> <p>Id: <code>0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00</code></p> <p>Method: <code>0x4578616d706c652e7472616e73666572</code> (utf-8 encoding of \"Example.transfer\")</p> <p>NonFungible(ERC721):</p> <p>Id: <code>0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501</code></p> <p>Method: <code>0x4578616d706c652e6d696e745f657263373231</code> (utf-8 encoding of \"Example.mint_erc721\")</p> <p>Generic (Hash Transfer):</p> <p>Id: <code>0x000000000000000000000000000000f44be64d2de895454c3467021928e55e01</code></p> <p>Method:  <code>0x4578616d706c652e72656d61726b</code> (utf-8 encoding of \"Example.remark\")</p>"},{"location":"local/#whitelist-chains","title":"Whitelist Chains","text":"<p>Steps to whitelist chains:</p> <ol> <li>Select the <code>Sudo</code> tab in the PolkadotJS Portal</li> <li>Call <code>chainBridge.whitelistChain</code>, specifying <code>0</code> for the Ethereum chain ID</li> </ol>"},{"location":"local/#run-relayer","title":"Run Relayer","text":"<p>Steps to run a relayer:</p> <ol> <li>Clone the ChainBridge repository</li> <li>Install the ChainBridge binary</li> <li>Create <code>config.json</code> using the sample provided below as a starting point</li> <li>Start relayer as a binary using the default \"Alice\" key</li> </ol> <p>Clone repo:</p> <pre><code>git clone git@github.com:ChainSafe/ChainBridge.git\n</code></pre> <p>Build ChainBridge and move it to your GOBIN path:</p> <pre><code>cd ChainBridge &amp;&amp; make install\n</code></pre> <p>Run relayer:</p> <pre><code>chainbridge --config config.json --testkey alice --latest\n</code></pre> <p>Or, if you prefer Docker, steps 2 and 4 can be done as follows:</p> <p>Build the ChainBridge docker image:</p> <pre><code>docker build -t chainsafe/chainbridge .\n</code></pre> <p>Start the relayer as a docker container:</p> <pre><code>docker run -v (pwd)/config.json:/config.json --network host chainsafe/chainbridge --testkey alice --latest </code></pre> <p>Sample <code>config.json</code>:</p> <pre><code>{\n\"chains\": [\n{\n\"name\": \"eth\",\n\"type\": \"ethereum\",\n\"id\": \"0\",\n\"endpoint\": \"ws://localhost:8545\",\n\"from\": \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\",\n\"opts\": {\n\"bridge\": \"0x62877dDCd49aD22f5eDfc6ac108e9a4b5D2bD88B\",\n\"erc20Handler\": \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\",\n\"erc721Handler\": \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\",\n\"genericHandler\": \"0x2B6Ab4b880A45a07d83Cf4d664Df4Ab85705Bc07\",\n\"gasLimit\": \"1000000\",\n\"maxGasPrice\": \"20000000\"\n}\n},\n{\n\"name\": \"sub\",\n\"type\": \"substrate\",\n\"id\": \"1\",\n\"endpoint\": \"ws://localhost:9944\",\n\"from\": \"5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY\",\n\"opts\": {\n\"useExtendedCall\":\"true\"\n}\n}\n]\n}\n</code></pre> <ul> <li>This is an example config file for a single relayer (\"Alice\") using the contracts we've deployed.</li> </ul>"},{"location":"local/#fungible-transfers","title":"Fungible Transfers","text":""},{"location":"local/#substrate-native-token-erc-20","title":"Substrate Native Token \u21d2 ERC 20","text":"<p>Steps to transfer an ERC-20 token:</p> <ol> <li>Select the <code>Extrinsics</code> tab in the PolkadotJS Portal</li> <li>Call <code>example.transferNative</code> with parameters such as these:<ul> <li>Amount: <code>1000</code> (select <code>Pico</code> for units)</li> <li>Recipient: <code>0xff93B45308FD417dF303D6515aB04D9e89a750Ca</code></li> <li>Dest Id: <code>0</code></li> </ul> </li> </ol> <p>You can query the recipients balance on Ethereum with this:</p> <p>Query token balance of account: Oxff..750Ca:</p> <pre><code>cb-sol-cli erc20 balance --address \"0xff93B45308FD417dF303D6515aB04D9e89a750Ca\"\n</code></pre>"},{"location":"local/#erc20-substrate-native-token","title":"ERC20 \u21d2 Substrate Native Token","text":"<p>If necessary, you can mint some tokens:</p> <p>Mint 1000 ERC20 tokens:</p> <pre><code>cb-sol-cli erc20 mint --amount 1000\n</code></pre> <p>Before initiating the transfer we have to approve the bridge to take ownership of the tokens:</p> <p>Approve bridge to assume custody of tokens:</p> <pre><code>cb-sol-cli erc20 approve --amount 1000 --recipient \"0x3167776db165D8eA0f51790CA2bbf44Db5105ADF\"\n</code></pre> <p>To initiate a transfer on the Ethereum chain use this command (Note: there will be a 10 block delay before the relayer will process the transfer):</p> <p>Transfer 1 token to account: 0xd4..da27d:</p> <pre><code>cb-sol-cli erc20 deposit --amount 1 --dest 1 --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\" --resourceId \"0x000000000000000000000000000000c76ebe4a02bbc34786d860b355f5a5ce00\"\n</code></pre>"},{"location":"local/#non-fungible-transfers","title":"Non-Fungible Transfers","text":""},{"location":"local/#substrate-nft-erc721","title":"Substrate NFT \u21d2 ERC721","text":"<p>First, you'll need to mint a token.</p> <p>Steps to mint an ERC-721 token:</p> <ol> <li>Select the <code>Sudo</code> tab in the PolkadotJS Portal</li> <li>Call <code>erc721.mint</code> with parameters such as these:<ul> <li>Owner: <code>Alice</code></li> <li>TokenId: <code>1</code></li> <li>Metadata: <code>\"\"</code></li> </ul> </li> </ol> <p>Now the owner of the token can initiate a transfer.</p> <p>Steps to transfer an ERC-721 token:</p> <ol> <li>Select the <code>Sudo</code> tab in the PolkadotJS Portal</li> <li>Call <code>example.transferErc721</code> with parameters such as these:<ul> <li>Recipient: <code>0xff93B45308FD417dF303D6515aB04D9e89a750Ca</code></li> <li>TokenId: <code>1</code></li> <li>DestId: <code>0</code></li> </ul> </li> </ol> <p>You can query ownership of tokens on Ethereum with this:</p> <p>Query ownership of ERC721 with token ID: 1:</p> <pre><code>cb-sol-cli erc721 owner --id 0x1\n</code></pre>"},{"location":"local/#erc721-substrate-nft","title":"ERC721 \u21d2 Substrate NFT","text":"<p>If necessary, you can mint an ERC-721 token like this:</p> <p>Mint ERC721 with token ID: 99:</p> <pre><code>cb-sol-cli erc721 mint --id 0x99\n</code></pre> <p>Before initiating the transfer, we must approve the bridge to take ownership of the tokens:</p> <p>Approve bridge to assume custody of ERC721 with token ID: 99:</p> <pre><code>cb-sol-cli erc721 approve --id 0x99 --recipient \"0x3f709398808af36ADBA86ACC617FeB7F5B7B193E\"\n</code></pre> <p>Now we can initiate the transfer:</p> <p>Transfer ERC721 with token ID: 99 to account: 0xd4..da27d:</p> <pre><code>cb-sol-cli erc721 deposit --id 0x99 --dest 1 --resourceId \"0x000000000000000000000000000000e389d61c11e5fe32ec1735b3cd38c69501\" --recipient \"0xd43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d\"\n</code></pre>"},{"location":"local/#generic-data-transfer","title":"Generic Data Transfer","text":"<p>To demonstrate a possible use of the generic data transfer, we have a hash registry on Ethereum. We also have a method on the example Substrate chain to emit a hash inside an event, which we can trigger from Ethereum. </p>"},{"location":"local/#generic-data-substrate-eth","title":"Generic Data Substrate \u21d2 Eth","text":"<p>For this example we will transfer a 32 byte hash to a registry on Ethereum. </p> <p>Steps to transfer data to Ethereum:</p> <ol> <li>Select the <code>Extrinsics</code> tab in the PolkadotJS Portal</li> <li>Call <code>example.transferHash</code> with parameters such as these:<ul> <li>Hash: <code>0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730</code></li> <li>Dest ID: <code>0</code></li> </ul> </li> </ol> <p>You can verify the transfer with this command:</p> <p>Verify transfer of hash:</p> <pre><code>cb-sol-cli cent getHash --hash 0x699c776c7e6ce8e6d96d979b60e41135a13a2303ae1610c8d546f31f0c6dc730\n</code></pre>"},{"location":"metrics/","title":"Metrics","text":"<p>Basic metrics and a health status check can be enabled with the <code>--metrics</code> flag (default port <code>8001</code>, use <code>--metricsPort</code> to specify).</p>"},{"location":"metrics/#prometheus","title":"Prometheus","text":"<p>Prometheus metrics are served on <code>/metrics</code>. For each chain that exists, this provides: - <code>&lt;chain&gt;_blocks_processed</code>: the number of blocks processed by the chains listener. - <code>&lt;chain&gt;_latest_processed_block</code>: most recent block that has been processed by the listener. - <code>&lt;chain&gt;_latest_known_block</code>: most recent block that exists on the chain. - <code>&lt;chain&gt;_votes_submitted</code>: number of votes submitted by the relayer.</p>"},{"location":"metrics/#health-check","title":"Health Check","text":"<p>The endpoint <code>/health</code> will return the current known block height, and a timestamp of when it was first seen for every chain:  ```json {   \"chains\": [     {       \"chainId\": \"Number\",       \"height\": \"Number\",       \"lastUpdated\": \"Date\"     }   ] } </p> <pre><code> If the timestamp is at least 120 seconds old an error will be returned instead:\n```json\n{\n  \"error\": \"String\"\n}\n</code></pre>"},{"location":"spec/","title":"ChainBridge Specification","text":""},{"location":"spec/#summary","title":"Summary","text":"<p>ChainBridge is a modular multi-directional blockchain bridge to allow data and value transfer between any number of  blockchains. This should enable users to specify a destination blockchain from their source chain, and send data to   that blockchain for consumption on the destination chain. This could be a token that is locked on ChainA and    redeemed on ChainB, or an operation that is executed on a destination chain and initiated on the source chain. The bridge     should maintain a set of relayers that are authorized to make &amp; process transfers across the different blockchains. The bridge design should be modular enough that the addition of a new type of transfer should not require a full re-deployment of the suite of tools, rather small modular upgrades.</p>"},{"location":"spec/#definitions","title":"Definitions","text":""},{"location":"spec/#chain-id","title":"Chain ID","text":"<p>Each chain has a unique 8-bit identifier. We presently define the following chain IDs (subject to change):</p> ID Chain 0 ETH Mainnet 1 ETC Mainnet 2 Centrifuge Network 3 Aragon Chain .. .."},{"location":"spec/#deposit-nonce","title":"Deposit Nonce","text":"<p>A nonce must be generated for every transfer to ensure uniqueness. All implementations must track a sequential nonce (unsigned 64-bit integer) for each possible destination chain. This is included as a standard parameter for each transfer. Order is not enforced.</p>"},{"location":"spec/#resource-id","title":"Resource ID","text":"<p>In order to provide generality, we need some way to associate some action on a source chain to some action on a destination chain. This may express tokenX on chain A is equivalent to tokenY on chain B, or to simply associate that some action performed on chain A should result in some other action occurring on chain B. </p> <p>All resource IDs are considered to have a Home Chain. The only strict requirements for Resource IDs is that they must be 32 bytes in length and the least significant byte must contain a chain ID. </p> <p>Resource IDs are arbitrary, you can use anything you like. The resource ID should be the same on every chain for the same token. One convention is use 0x0... to indicate where the token originates from. You would use a different resource ID from each token that is supported, or for any arbitrary action via the generic handler. The format is just a suggestion, and the chain ID included is in reference to the origin chain where the token was first created."},{"location":"spec/#transfer-flow","title":"Transfer Flow","text":"<ol> <li>User initiates a transfer on the source chain.</li> <li>Relayers observing the chain parse the parameters of the transfer and format them into a message.</li> <li>The message is parsed and then proposed on the destination chain.</li> <li>If the vote threshold is met, the proposal will be executed to finalize the transfer.</li> </ol> <p>After the initiation, a user should not be required to make any additional interactions.</p>"},{"location":"spec/#transfer-types","title":"Transfer Types","text":"<p>In a effort to balance the goals of allowing simple integration and proving generalized transfers, multiple transfer types are defined. Some or all of these may implemented for a chain.</p> Event Description FungibleTransfer Transfer of fungible assets NonFungibleTransfer Transfer of non-fungible assets GenericTransfer Transfer of arbitrary data <p>All transfers contain a source chain, destination chain, deposit nonce, resource ID and transfer-specific parameters.</p>"},{"location":"spec/#fungible","title":"Fungible","text":"Field Type Description Amount 256 bit uint The total number of assets being transferred Recipient 32 bytes The recipient address on the destination chain"},{"location":"spec/#non-fungible","title":"Non-Fungible","text":"Field Type Description Token ID 256 bit uint The unique identifier for the NFT Recipient 32 bytes The recipient address on the destination chain Metadata variable sized bytes Any additional data associated to the NFT"},{"location":"spec/#generic","title":"Generic","text":"Field Type Description Metadata variable sized bytes An opaque payload to transmit <p>Note: Addresses are limited to 32bytes in size, but may be smaller. They must always be compatible with the destination chain.</p>"},{"location":"spec/#relayer-set","title":"Relayer Set","text":"<p>Each chain implementation must track a set of relayers, and allow updating of the set as necessary. A threshold should also be maintained to define how many relayers must vote for a proposed transfer before is can be executed. For this initial implementation, the relayer set may be controlled by a single party. Multi-signature wallets can be used to distribute risk, if available on the chain.</p>"},{"location":"spec/#implementation","title":"Implementation","text":"<p>This sections defines the specifics of the ChainBridge implementation and the requirements for a chain integration.</p>"},{"location":"spec/#components","title":"Components","text":""},{"location":"spec/#chain","title":"Chain","text":"<p>A chain is loosely defined as consisting of three major components:</p> <ul> <li>Connection: A container for on chain interactions. Shared by the listener and writer.</li> <li>Listener:  Observes chain state transitions to watch for initiated transfers. When a transfer is encountered it should construct a message and pass it to the router.</li> <li>Writer: Responsible for performing on-chain actions. This will parse a proposed transfer from a message and enact it on-chain. </li> </ul> <p>These vary considerably depending on the chain. As long as the on-chain components are compatible, following the internal message protocol should be sufficient to be compatible with the system. These components are intended for architectural guidance and are only loosely constrained.</p>"},{"location":"spec/#message","title":"Message","text":"<p>A message represents a single transfer and its associated parameters. </p> <pre><code>type Message struct {\nSource       ChainId   Destination  ChainId Type         TransferType\nDepositNonce Nonce\nResourceId   ResourceId\nPayload      []interface{}\n}\n</code></pre> <p>The <code>payload</code> field contains the data for the specific transfer, as defined above.</p>"},{"location":"spec/#router","title":"Router","text":"<p>The router is responsible for taking messages from a source chain and routing them to their destination chain.</p> <p>The router provides an interface to allow Listeners to submit constructed messages:</p> <pre><code>type Router interface {\nSend(message msg.Message) error\n}\n</code></pre> <p>All chains must fulfill a Writer interface to receive messages from the router:</p> <pre><code>type Writer interface {\nResolveMessage(message msg.Message) bool\n}\n</code></pre>"},{"location":"test/","title":"Testing","text":"<p>Unit tests require an ethereum node running on <code>localhost:8545</code> and a substrate node running on <code>localhost:9944</code>. E2E tests require an additional ethereum node on <code>localhost:8546</code>. </p> <p>A docker-compose file is provided to run two Geth nodes and a chainbridge-substrate-chain node in isolated environments:</p> <pre><code>$ docker-compose -f ./docker-compose-e2e.yml up\n</code></pre> <p>See chainbridge-solidity and chainbridge-substrate-chain for more information on testing facilities.</p> <p>All Go tests can be run with:</p> <pre><code>$ make test\n</code></pre> <p>Go tests specifically for ethereum, substrate and E2E can be run with</p> <pre><code>$ make test-eth\n$ make test-sub\n$ make test-e2e\n</code></pre> <p>The bindings for the solidity contracts live in <code>bindings/</code>. To update the bindings modify <code>scripts/setup-contracts.sh</code> and then run <code>make clean &amp;&amp; make setup-contracts</code></p>"},{"location":"chains/eth-contracts/","title":"Ethereum Contracts","text":""},{"location":"chains/eth-contracts/#bridge-contract","title":"Bridge Contract","text":"<p>Users and relayers will interact with the <code>Bridge</code> contract. This delegates calls to the handler contracts for deposits and executing proposals.</p> <pre><code>function deposit (uint8 destinationChainID, bytes32 resourceID, bytes calldata data)\n</code></pre>"},{"location":"chains/eth-contracts/#handler-contracts","title":"Handler Contracts","text":"<p>To provide modularity and break out the necessary contract logic, the implementation uses a notion of handlers. A handler is defined for ERC20, ERC721 and generic transfers. These map directly to the Fungible, Non-Fungible, and generic transfer types.</p> <p>A handler must fulfill two interfaces:</p> <pre><code>// Will be called by the bridge contract to initiate a transfer\nfunction deposit(uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data)\n</code></pre> <pre><code>// TODO: This would be more aptly named executeProposal\n// Called by the bridge contract to complete a transfer\nfunction executeDeposit(bytes calldata data)\n</code></pre> <p>The <code>calldata</code> field is the parameters required for the handler. The exact serialization is defined for each handler.</p>"},{"location":"chains/eth-contracts/#erc20-erc721-handlers","title":"ERC20 &amp; ERC721 Handlers","text":"<p>These handlers share a lot of similarities.</p> <p>These handlers are responsible for transferring ERC assets. They should provide the ability for the bridge to take ownership of tokens and release tokens to execute transfers.</p> <p>Different configurations may require different interface interactions. For example, it may make sense to mint and burn a token that is originally from another chain. If supply needs to be controlled, transferring tokens in and out of a reserve may be desired instead. To support either case handlers should associate each resource ID/token contract with one of these:</p> <ul> <li><code>transferFrom()</code> - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call <code>transferFrom()</code> as part of the transfer initiation. For the inverse, the handler will call <code>transfer()</code> to release tokens from the handlers ownership.</li> <li><code>mint()</code>/<code>burn()</code> - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call <code>burnFrom()</code> as part of the transfer initiation. For the inverse, the handler will call <code>mint()</code> to release tokens to the recipient (and must have privileges to do so).</li> </ul>"},{"location":"chains/eth-contracts/#erc20-handler","title":"ERC20 Handler","text":""},{"location":"chains/eth-contracts/#calldata-for-deposit","title":"Calldata for <code>deposit()</code>","text":"Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END"},{"location":"chains/eth-contracts/#calldata-for-executedeposit","title":"Calldata for <code>executeDeposit()</code>","text":"Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - END"},{"location":"chains/eth-contracts/#erc721-handler","title":"ERC721 Handler","text":""},{"location":"chains/eth-contracts/#metadata","title":"Metadata","text":"<p>The <code>tokenURI</code> should be used as the <code>metadata</code> field if the contract supports the Metadata extension (interface ID <code>0x5b5e139f</code>).</p>"},{"location":"chains/eth-contracts/#calldata-for-deposit_1","title":"Calldata for <code>deposit()</code>","text":"Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END"},{"location":"chains/eth-contracts/#calldata-for-executedeposit_1","title":"Calldata for <code>executeDeposit()</code>","text":"Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - 95 Metadata Length uint256 96 - 127 Metadata bytes 128 - END"},{"location":"chains/eth-contracts/#generic-handler","title":"Generic Handler","text":"<p>As well as associating a resource ID to a contract address, the generic handler should allow specific functions on those contracts to be used. To allow for this we must:</p> <ol> <li>Use function selectors to identify functions.</li> <li>Require functions that accept <code>bytes</code> as a the only parameter OR require the data already be ABI encoded for the function</li> </ol>"},{"location":"chains/eth-contracts/#deposit","title":"Deposit","text":"<p>In a generic context, a deposit is simply the initiation of a transfer of a piece of data. To (optionally) allow this data to be validated for transfer the deposit mechanism should pass the data to a specified function and proceed with the transfer if the call succeeds (ie. does not revert). A function selector of <code>0x00</code> should skip the deposit function call.</p>"},{"location":"chains/eth-contracts/#execute","title":"Execute","text":"<p>An execution function must be specified. When <code>executeDeposit()</code> is called on the handler it should pass the <code>metadata</code> field to the specified function.</p>"},{"location":"chains/eth-contracts/#calldata-for-deposit_2","title":"Calldata for <code>deposit()</code>","text":"Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END"},{"location":"chains/eth-contracts/#calldata-for-execute","title":"Calldata for <code>execute()</code>","text":"Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END"},{"location":"chains/eth-contracts/#administration","title":"Administration","text":"<p>The contracts should be controlled by an admin account. This should control the relayer set, manage the resource IDs, and specify the handlers. It should also be able to pause and unpause transfers at any times.</p>"},{"location":"chains/ethereum/","title":"Ethereum Implementation Specification","text":"<p>The solidity implementation of ChainBridge should consist of a central Bridge contract, and will delegate specific functionality to handlers. Fungible and non-fungible compatibility should be focused on ERC20 and ERC721 tokens.</p>"},{"location":"chains/ethereum/#transfer-flow","title":"Transfer Flow","text":""},{"location":"chains/ethereum/#as-source-chain","title":"As Source Chain","text":"<ol> <li> <p>Some user calls the <code>deposit</code> function on the bridge contract. A <code>depositRecord</code> is created on the bridge and a call is delgated to a handler contract specified by the provided <code>resourceID</code>.</p> </li> <li> <p>The specified handler's <code>deposit</code> function validates the parameters provided by the user. If successful, a <code>depositRecord</code> is created on the handler.</p> </li> <li> <p>If the call delegated to the handler is succesful, the bridge emits a <code>Deposit</code> event.</p> </li> <li> <p>Relayers parse the <code>Deposit</code> event and retrieve the associated <code>DepositRecord</code> from the handler to construct a message.</p> </li> </ol>"},{"location":"chains/ethereum/#as-destination-chain","title":"As Destination Chain","text":"<ol> <li> <p>A Relayer calls <code>voteProposal</code> on the bridge contract. If a <code>proposal</code> corresponding with the parameters passed in does not exist, it is created and the Relayer's vote is recorded. If the proposal already exists, the Relayer's vote is simply recorded.</p> </li> <li> <p>Once we have met some vote threshold for a <code>proposal</code>, the bridge emits a <code>ProposalFinalized</code> event.</p> </li> <li> <p>Upon seeing a <code>ProposalFinalized</code> event, Relayers call the<code>executeDeposit</code>function on the bridge. <code>executeDeposit</code> delegates a call to a handler contract specified by the associated <code>resourceID</code>.</p> </li> <li> <p>The specified handler's <code>executeDeposit</code> function validates the parameters provided and makes a call to some contract to complete the transfer.</p> </li> </ol>"},{"location":"chains/substrate/","title":"Substrate Implementation Specification","text":"<p>The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. </p> <p>Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a <code>Proposal</code> type equivalent to a dispatchable call to theoretically allow for any call to be made.</p> <pre><code>pub trait Trait: system::Trait {\ntype Proposal: Parameter + Dispatchable&lt;Origin = Self::Origin&gt; + EncodeLike + GetDispatchInfo;\n}\n</code></pre>"},{"location":"chains/substrate/#events","title":"Events","text":"<p>To easily distinguish different transfer types we should define three event types:</p> <pre><code>/// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata)\nFungibleTransfer(ChainId, DepositNonce, ResourceId, U256, Vec&lt;u8&gt;)\n\n/// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata)\nNonFungibleTransfer(ChainId, DepositNonce, ResourceId, Vec&lt;u8&gt;, Vec&lt;u8&gt;, Vec&lt;u8&gt;)\n\n/// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata)\nGenericTransfer(ChainId, DepositNonce, ResourceId, Vec&lt;u8&gt;)\n</code></pre> <p>These can be observed by relayers and should provide enough context to construct transfer messages. </p>"},{"location":"chains/substrate/#inter-pallet-communication","title":"Inter-Pallet Communication","text":"<p>The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers:</p> <pre><code>pub fn transfer_fungible(dest_id: ChainId, resource_id: ResourceId, to: Vec&lt;u8&gt;, amount: U256,)\n\npub fn transfer_nonfungible(dest_id: ChainId, resource_id: ResourceId, token_id: Vec&lt;u8&gt;, to: Vec&lt;u8&gt;, metadata: Vec&lt;u8&gt;)\n\npub fn transfer_generic(dest_id: ChainId, resource_id: ResourceId, metadata: Vec&lt;u8&gt;)\n</code></pre> <p>These should result in the associated event being emitted with the correct parameters.</p>"},{"location":"chains/substrate/#bridge-account-id-origin-check","title":"Bridge Account ID &amp; Origin Check","text":"<p>To allow the bridge pallet to take ownership of tokens a <code>ModuleId</code> should be used to derive an <code>AccountId</code>.</p> <p>A bridge origin check (implementing <code>EnsureOrigin</code>) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal.</p>"},{"location":"chains/substrate/#executing-calls","title":"Executing Calls","text":"<p>The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin.</p> <p>Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls:  - Fungible: <code>Call(origin, recipient: AccountId, amount: u128)</code> - Non-Fungible: <code>Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec&lt;u8&gt;)</code> - Generic: <code>Call(origin, data: Vec&lt;u8&gt;)</code></p> <p>Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls </p>"}]}